<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2020/10/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/10/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>针对面向对象的一种设计方式的总结，是对面向对象中的各种问题的解决办法的总结</li><li>提供解决问题的一种抽象的描述、方案</li><li>一共有23种设计模式，称为“ GoF 23 ”<br><img src="image_20201020161914.png"></li></ul><h2 id="OOP七大原则"><a href="#OOP七大原则" class="headerlink" title="OOP七大原则"></a>OOP七大原则</h2><ul><li>开闭原则：对扩展开放，对修改关闭</li><li>里氏替换原则：继承必须保证超类所拥有的性质在子类中仍然成立</li><li>依赖倒置原则：面向接口编程，不要面向实现编程</li><li>单一职责原则：控制类的粒度大小，将对象解耦、提高内聚性</li><li>接口隔离原则：要为各个类建立它们需要的专用接口</li><li>迪米特法则：只与直接朋友交谈，不和陌生人说话</li><li>合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次考虑使用继承关系来实现</li></ul><blockquote><p>创建型模式</p></blockquote><h1 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h1><h3 id="饿汉式单例：类加载时就创建其对应的实例，但是这样会比较浪费内存空间"><a href="#饿汉式单例：类加载时就创建其对应的实例，但是这样会比较浪费内存空间" class="headerlink" title="饿汉式单例：类加载时就创建其对应的实例，但是这样会比较浪费内存空间"></a>饿汉式单例：类加载时就创建其对应的实例，但是这样会比较浪费内存空间</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HungryMan</span> </span>&#123;      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> HungryMan HUNGRY_MAN = <span class="hljs-keyword">new</span> HungryMan();    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HungryMan</span><span class="hljs-params">()</span> </span>&#123;  &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HungryMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> HUNGRY_MAN;    &#125;  &#125;</code></pre><h3 id="懒汉式单例：只在用到这个单例的时候才实例化对象"><a href="#懒汉式单例：只在用到这个单例的时候才实例化对象" class="headerlink" title="懒汉式单例：只在用到这个单例的时候才实例化对象"></a>懒汉式单例：只在用到这个单例的时候才实例化对象</h3><pre><code class="hljs java"><span class="hljs-comment">//基本的想法是这样子的，在用到时进行实例化即可</span><span class="hljs-comment">//但是这样的代码在多线程下是存在问题的，多线程下不能保证单例</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyMan</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazyMan</span><span class="hljs-params">()</span> </span>&#123;    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LazyMan lazyMan;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazyMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span> (lazyMan == <span class="hljs-keyword">null</span>) &#123;      lazyMan = <span class="hljs-keyword">new</span> LazyMan();  &#125;  <span class="hljs-keyword">return</span> lazyMan;  &#125;  &#125;<span class="hljs-comment">// 所以考虑使用加锁的方式来进行</span><span class="hljs-comment">// 使用双重检测锁模式的 懒汉式单例 DCL懒汉式</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyMan</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazyMan</span><span class="hljs-params">()</span> </span>&#123;      &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> LazyMan lazyMan;  <span class="hljs-comment">//注意这里使用的volatile关键字</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazyMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">if</span> (lazyMan == <span class="hljs-keyword">null</span>) &#123;  <span class="hljs-keyword">synchronized</span> (LazyMan.class) &#123;  <span class="hljs-keyword">if</span> (lazyMan == <span class="hljs-keyword">null</span>) &#123;  lazyMan = <span class="hljs-keyword">new</span> LazyMan();  &#125;  &#125;  &#125;  <span class="hljs-keyword">return</span> lazyMan;  &#125;  &#125;</code></pre><ul><li>这里使用的<code>volatile</code>关键字其实是出于安全的考虑来进行的</li><li>问题来自于<code>new</code>一个新的对象这步操作并不是原子操作，这里其实发生了三部操作：<ol><li>分配内存空间</li><li>执行构造方法，初始化对象</li><li>把对象引用指向这个空间</li></ol></li><li>但是实际在执行时，很可能不是完全按照这个顺序来进行的，这就会导致引用已经指向了一块空间，但是这块空间很可能还没有完成初始化的操作，这就会导致另一个线程来调用时出现问题</li><li>而这里的<code>volatile</code>关键字保证了 <strong>可见性</strong> 和 <strong>有序性</strong></li></ul><h3 id="通过内部类来创建（略）"><a href="#通过内部类来创建（略）" class="headerlink" title="通过内部类来创建（略）"></a>通过内部类来创建（略）</h3><h3 id="通过反射破坏单例"><a href="#通过反射破坏单例" class="headerlink" title="通过反射破坏单例"></a>通过反射破坏单例</h3><ul><li>通过反射去获取到私有的构造器，然后创建新的实例</li></ul><pre><code class="hljs java">Constructor con = LazyMan.class.getDeclaredConstructor(<span class="hljs-keyword">null</span>);  LazyMan lazyMan1 = (LazyMan) con.newInstance();  LazyMan lazyMan2 = LazyMan.getInstance();</code></pre><ul><li>这种方式可以通过在构造器中设置检测来解决</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazyMan</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">synchronized</span> (LazyMan.class) &#123;          <span class="hljs-keyword">if</span> (lazyMan != <span class="hljs-keyword">null</span>) &#123;              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;不要试图通过反射破坏单例&quot;</span>);  &#125;      &#125;  &#125;</code></pre><ul><li>其实这样的办法依然是有问题的，不能永远的解决单例被反射破坏的问题</li><li>现在标准的做法是通过枚举类型从本质上来解决（反射是不会对枚举类型起作用的，从<code>newInstance</code>的源码中可以看到不会反射枚举对象）</li></ul><h1 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h1><ul><li>创建者和调用者分离</li><li>详细分类：<ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul></li><li>核心是：对象实例化不使用<code>new</code>，用工厂方法代替；使用工厂来进行对象创建的统一管理</li></ul><h2 id="简单工厂模式（静态工厂模式）"><a href="#简单工厂模式（静态工厂模式）" class="headerlink" title="简单工厂模式（静态工厂模式）"></a>简单工厂模式（静态工厂模式）</h2><ul><li>将对象的创建委托给工厂，比较适用于需要传入很多参数的那种对象创建场景</li><li>但是这种静态的工厂模式有一个问题，没有满足开闭原则；当需要对工厂进行扩展时，必须对工厂类的源码进行改变，而不能直接进行扩展。</li><li>通过一个统一的工厂去生产所有的实例对象，工程中最常用的办法</li></ul><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><ul><li>定义统一的工厂的接口，针对每种产品都要编写对应的工厂实现</li><li>这样就可以保证代码的开闭原则了，但是这样会是的使代码量和类的结构相当复杂，一般不推荐这么使用</li></ul><h1 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3. 抽象工厂模式"></a>3. 抽象工厂模式</h1><ul><li>抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类</li><li>围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂</li><li>首先定义要生产的产品的接口，一个产品可以有多个具体的产品实现（多个品牌的手机）；每个接口对应特定的一种产品（品牌旗下的不同的产品种类）</li><li>然后定义抽象工厂的接口，在抽象工厂中定义对每种产品生产的接口</li><li>然后由品牌商实现具体的工厂，并实现生产自己的各种产品</li><li>在需求比较稳定的情况下是很强大的，可以增加产品簇，但是如果工厂的需求不稳定，接口的更改会导致很多类的更改</li></ul><h1 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4. 建造者模式"></a>4. 建造者模式</h1><ul><li>将一个复杂对象的构建与它的表示分离，在用户不知道对象的创建过程和细节的情况下就可以直接创建复杂的对象</li><li>同样的构创建过程可以创建不同的表示</li><li>隔离了复杂对象的创建与使用，其实就是对应了<strong>工人</strong>和<strong>指挥</strong>两者，分别去完成不同的功能</li><li>和工厂模式相对比来说，工厂模式是通过直接调用工厂类来获取产品的；而建造者模式中，客户不直接调用建造者的方法，而是通过一个指挥类，来指导如何生成对象。它更倾向于一步步构造一个复杂对象，返回一个完整的对象</li></ul><h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><ul><li>首先整个模型由四个部分组成：核心的产品、构建的统一接口、构建的具体实现工人、工人的指挥者</li></ul><ol><li>产品 ( Product ) 所代表的是需要我们构建的东西，要去生产的一个物品，这个物品的生产往往需要大量的步骤来完成</li><li>构建的统一接口 ( Builder ) 是我们人为定义的，要完成这个产品的构建所需要的大概步骤、要完成的工作概括；还要保证有一个返回构建好的产品的方法</li><li>然后需要一个工人 ( Worker ) 来具体实现<strong>构建接口</strong>中所定义的具体工作任务；在工人的构造器中去<code>new</code>一个产品的对象出来，然后实现接口定义的对产品的构建工作，最后完成产品的返回方法</li><li>最后是指挥者 ( Director ) 按照需要的顺序来调用工人，完成对产品的构建工作，最后获取到这个产品。（这里有一个注意点，其实指挥者是不直接调用工人的，而是调用的Builder接口，然后使用了多态的特性可以传入不同的工人）</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><ul><li>这个模式对于某一个具体产品的构建，只要完成构建需要做的工作大概是相同的，就可以通过统一的Builder接口定义要完成的工作量</li><li>然后由工人实现具体的步骤，工人是可以实现多个的，通过多态的方式定义多个工人完成差异化的工作</li><li>最后指挥者来调度工人工作的步骤，当然指挥者的角色可以由调用程序来承担</li></ul><h1 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5. 原型模式"></a>5. 原型模式</h1><ul><li>以某个对象为原型，创建一个新的对象，也就是copy一份 (<code>Cloneable</code>接口，<code>clone()</code>方法)</li><li>这里的克隆是通过native方法调用底层来实现的，直接在内存的层面上来进行的拷贝，效率非常高</li><li>一般 原型模式 会和 工厂模式 结合起来使用，工厂在创建新对象的时候不再采用<code>new</code>关键字去创建新对象，而是采用<code>clone()</code>方法来产生新的对象，来达到更高的效率</li></ul><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><ul><li>需要通过原型模式来拷贝的类，需要继承一个<code>Cloneable</code>接口，并且重写<code>clone()</code>方法；然后对某一个对象调用这个方法就可以创建并返回其副本了</li></ul><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><ul><li>直接这样调用<code>clone()</code>方法完成的拷贝都是==浅克隆==，即当这个对象的实例变量中存在引用时，那么直接拷贝出来的对象和原对象中的这些引用都是指向同一个对象的。这显然不是我们希望的结果</li><li>我们需要完成==深克隆==，其中一个比较简单的办法是在<code>clone()</code>方法中将每个引用对象再clone一遍</li><li>除此之外还可以通过序列化和反序列化来实现，不过这个会涉及到IO的操作，效率不会特别高</li></ul><blockquote><p>结构型模式  这类模式是为了实现代码的松耦合的</p></blockquote><h1 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6. 适配器模式"></a>6. 适配器模式</h1><ul><li>相当于电脑的拓展坞的功能，当功能模块提供的接口与使用者之间不统一的时候，就需要一个中间的适配器来连接两者</li><li>适配器在实现时有继承和组合两种方式，分别对应了类适配器和对象适配器两种</li></ul><h3 id="实现：-1"><a href="#实现：-1" class="headerlink" title="实现："></a>实现：</h3><ul><li>首先要定义适配器完成的功能的接口，直接对调用者传入这个接口类型的对象</li><li>然后通过一个适配器的具体实现类，完成需要的功能；这个适配器的实例需要直接传入调用者对象，完成功能的调用</li><li>在实现适配器的时候，我们更多选择<strong>组合模式</strong>；也就是在适配器实例中定义提供功能的模块的引用的实例变量，然后在适配器的构造器中定义传入这个功能模块的实例</li><li>这样，被适配对象的功能模块的实例 =传入=&gt; 适配器， 适配器实例 =传入=&gt; 调用模块</li></ul><h1 id="7-桥接模式"><a href="#7-桥接模式" class="headerlink" title="7. 桥接模式"></a>7. 桥接模式</h1><ul><li>将抽象部分与实现部分分离，又称 柄体模式 或 接口模式</li><li>适合处理多维度变化的场景，当一个类存在两个独立变化的维度，而且这两个维度都需要就行扩展时，桥接模式就可以大大降低代码的数量<br><img src="image_20201021221500.png"></li></ul><h3 id="实现：-2"><a href="#实现：-2" class="headerlink" title="实现："></a>实现：</h3><ul><li>以上面的这个二位图为例子，将一个产品分成了品牌和类型两个维度</li></ul><ol><li>首先定义品牌的接口，定义和品牌相关的相关操作</li><li>然后，创建具体产品的抽象类；在这个抽象类中要通过组合的方式，将具体的品牌实例传入其中，并定义产品的相关操作</li><li>最后，需要具体实现品牌和产品，我们在将产品实例化的时候需要传入其品牌对应的实例，这样通过组合的方式得到了一个具体的产品</li></ol><h1 id="8-代理模式"><a href="#8-代理模式" class="headerlink" title="8. 代理模式"></a>8. 代理模式</h1><ul><li>代理模式是Spring AOP的底层实现</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><ul><li>静态代理是通过一个中介对象去代理原来的真实对象完成相关的操作；但不是简单的将已经具备的功能重复实现一遍，而是要对原来真实对象提供的功能做一定的扩展，这里的扩展包括了已经具备的方法的扩展和还没有的方法的扩展两种</li><li>那么客户在调用对象的时候就不再调用原来的真实对象，而是通过中间人代理的方式调用，这样的方式可以获得更多的功能</li><li>这样的代理方式具有很强的扩展性，对于以前的代码的功能扩展是非常好的解决办法，避免了源码的大量改动</li><li>但是，显然这样的方式需要针对每个真实的对象去实现一个代理对象，这会导致源码的数量翻倍；为了避免这样的情况，就需要动态代理的方式，通过一个代理类去代理多个不同的真实对象</li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul><li>核心是通过反射来实现</li><li>动态代理的代理类是动态生成的，而静态代理就需要我们自己手动写代理类 </li><li>动态代理的分类：<ul><li>基于接口：JDK原生的方式实现<ul><li>Java字节码实现：JAVAssist (现在最常用的方式)</li></ul></li><li>基于类：GCLIB的实现</li></ul></li></ul><h3 id="实现：-3"><a href="#实现：-3" class="headerlink" title="实现："></a>实现：</h3><ul><li>需要了解两个类：<code>Proxy</code>（代理）、<code>InvocationHandler</code>（调用处理程序）</li><li>首先需要定义一个继承<code>InvocationHandler</code>接口的代理实现类，继承这个接口之后必须要实现一个<code>Object invoke(Object proxy, Method method, Object[] args)</code>方法，这个方法就是最后通过代理对象调用被代理对象时，会代理调用的方法，我们可以在这个方法里面定义我们需要附件的各种操作</li><li>在这个<code>invoke</code>方法中，我们一般需要保证原方法正常执行，所以需要通过反射的方式调用一下原方法<code>method.invoke(target,args);</code>；当然也可能不执行原方法了，替换为别的业务逻辑代码</li><li>然后，我们需要去获取到一个JVM自动生成的代理类，通过<code>Proxy</code>类提供的静态方法就可以获取了：<code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>；需要注意的是，这里传入的参数，加载器我们就选择被代理对象的加载器，接口则必然是被代理对象实现的接口了（这里其实也预示着，所有被代理的方法都是那些接口中定义过的方法，被代理对象自己定义的方法是不会被代理的，那么代理对象也就没有办法调用到那些方法），最后的这个<code>InvocationHandler</code>参数其实代表了选择哪个代理的实现，即调用哪个具体实现的<code>invoke</code>方法来进行代理</li><li>上一条中提到的关于接口的那个问题，其实在调用这个静态方法自动生成动态代理类的时候是只能将其类型强制转换为接口类型的，那么这也就表示着很多功能会有所限制（好好理解）</li><li>总的来说，动态代理使用了两次反射来完成这个工作，动态代理类是<strong>自动生成</strong>的，而静态代理则是手动书写的</li></ul><h3 id="最后给出一个动态代理的模板"><a href="#最后给出一个动态代理的模板" class="headerlink" title="最后给出一个动态代理的模板"></a>最后给出一个动态代理的模板</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-comment">//被代理的接口  </span><span class="hljs-keyword">private</span> Object target;  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">bind</span><span class="hljs-params">(Object target)</span> </span>&#123;  <span class="hljs-keyword">this</span>.target = target;<span class="hljs-keyword">return</span> target;&#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),  target.getClass().getInterfaces(), <span class="hljs-keyword">this</span>);  &#125;        <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;          Object res = method.invoke(target,args);   <span class="hljs-keyword">return</span> res;  &#125; &#125;</code></pre><h1 id="9-享元模式"><a href="#9-享元模式" class="headerlink" title="9. 享元模式"></a>9. 享元模式</h1><ul><li>主要用于减少创建对象的数量，以减少内存占用和提高性能</li><li><code>String</code>的常量池技术就是采用享元模式设计的，通过共用相同的对象来减少大量的细粒度的对象对堆内存空间的消耗</li></ul><blockquote><p>行为型模式</p></blockquote><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><ul><li>源于Java提供的一项语法糖 <code>for(String str : list)</code></li><li>使用这样简洁的表达方式就可以表达遍历<code>list</code>列表中的每一个对象，但是这是通过语法糖实现的，最终通过<code>javac</code>编译时，会还原成<code>Iterator</code>的表达方式</li><li>上面的这条语句反编译后的结果是</li></ul><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Iterator iterator = list.iterator(); iterator.hasNext();)  &#123;      String i = (String)iterator.next();  &#125;</code></pre><ul><li>所以<code>for-each</code>句型其实Java的语法糖，本质都是通过迭代器来实现的</li><li>迭代器模式的实现需要通过两个接口<code>Iterator</code> 和 <code>Iterable</code> </li></ul><h3 id="实现：-4"><a href="#实现：-4" class="headerlink" title="实现："></a>实现：</h3><ul><li>需要迭代的对象要实现<code>Iterable</code> 接口中的<code>Iterator&lt;T&gt; iterator()</code>方法</li><li>显然这里要返回的是一个<code>Iterator</code>接口的对象，而这个对象是需要实现<code>hasNext() &amp; next()</code>方法的</li><li>所以我们其实还需要在这个类的内部在定义一个<code>private</code>的<code>Iterator</code>实现类，然后在<code>Iterator&lt;T&gt; iterator()</code>方法返回的时候<code>new</code>一个这个内部类的实例</li><li>我们之所以不直接对要迭代的类实现<code>Iterator</code>接口，是因为这样我们就只能定义一种迭代的方式，但是通过返回<code>Iterator</code>实例的方式就可以在内部多定义几种迭代的方式，根据需要返回迭代的实例，进行不同类型的迭代</li></ul><h3 id="给出一个迭代实现的例子"><a href="#给出一个迭代实现的例子" class="headerlink" title="给出一个迭代实现的例子"></a>给出一个迭代实现的例子</h3><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-keyword">int</span> length;  String[] name;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;String&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Itr();  &#125;        <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;  <span class="hljs-keyword">int</span> ptr;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> ptr &lt; length;  &#125;            <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;              <span class="hljs-keyword">return</span> name[ptr++];  &#125;      &#125;  &#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2020/10/25/JVM/"/>
    <url>/2020/10/25/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM探究"><a href="#JVM探究" class="headerlink" title="JVM探究"></a>JVM探究</h1><h2 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h2><ul><li>运行在操作系统上的一个软件</li><li>JRE(包含JVM) 就是Java程序的运行环境</li><li>JVM是用C++写的</li></ul><h2 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h2><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1322884520,2883030332&fm=26&gp=0.jpg" alt="JVM结构"></p><ul><li>方法区在1.8之后就由==“元空间”==了</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="作用：加载Class文件"><a href="#作用：加载Class文件" class="headerlink" title="作用：加载Class文件"></a>作用：加载Class文件</h3><ul><li>对于我们所编写的一个Car对象，在编译之后会形成.class文件</li><li>在运行Java程序时，类加载器会首先加载和初始化这个Car类，形成一个 Car class 的抽象模板（每个类的模板只有一个）</li><li>这些加载器提取出来的Class对象是存放在方法区的</li><li>当程序中执行<code>Car car1 = new Car()</code>这样的语句时</li><li><code>car1</code>作为引用名存储在栈当中，而<code>new</code>出来的实例对象是存储在堆区的<br><img src="image_20200713154355.png"></li></ul><h3 id="加载器："><a href="#加载器：" class="headerlink" title="加载器："></a>加载器：</h3><ul><li>虚拟机自带的加载器</li><li>BOOT：启动类加载器（根加载器）在rt.jar包中</li><li>EXT：扩展类加载器 在jre/lib/ext 文件下</li><li>APP：应用程序加载器</li><li>可以调用Class对象的<code>getClassLoader()</code>方法去获取类加载器</li></ul><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><ol><li>类加载器收到加载请求</li><li>将这个加载请求向上委托给父类加载器完成，并一直向上委托到根加载器 (APP –&gt; EXT –&gt; BOOT)</li><li>从根加载器开始检测能否加载这个类，可以加载则使用当前的加载器；不能则抛出异常通知子加载器 (BOOT –&gt; EXT –&gt; APP)</li></ol><p><strong>安全</strong></p><ul><li>“双亲委派机制”是为了保证安全所采取的机制</li><li>通过这样的机制，当我们自定义了一个<code>java.lang.String</code>这样的类时，根加载器会优先从JRE的rt.jar包中加载这个类，而不会等到应用程序加载器来加载我们自定义的类</li><li>这样我们就实现了核心类库的安全性，可以防篡改</li><li>同样，在EXT对应的jre/lib/ext 文件下的类，也可以利用这样的“双亲委派机制”来保证类的安全性</li></ul><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><ul><li>限制程序运行的环境，将Java代码限定到虚拟机特定的运行范围中。严格限制代码对本地系统资源的访问</li><li>对远程代码的安全性进行检查，后来引入保护域的概念</li></ul><h3 id="沙箱基本组件"><a href="#沙箱基本组件" class="headerlink" title="沙箱基本组件"></a>沙箱基本组件</h3><ul><li>字节码校验器：Java语法规范检验，帮助实现内存保护。核心类不会检验</li><li>类加载器：三个方面对Java沙箱起作用<ul><li>防止恶意代码干涉善意代码（双亲委派机制）</li><li>守护信任类库边界</li><li>将代码归入保护域，限制代码可以执行的操作</li></ul></li></ul><h2 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h2><ul><li>拥有native关键字的方法，是Java的作用范围达不到的操作，需要调用底层的C/C++库</li><li>调用native方法时，会进入本地方法栈中</li><li>本地方法栈会去调用本地方法接口(==JNI==)，通过JNI再调用到本地方法库</li><li>JNI作用：扩展Java的使用，融合不同的编程语言为Java所用；JNI是公开的接口，可以自定义</li></ul><h3 id="But"><a href="#But" class="headerlink" title="But"></a>But</h3><ul><li>企业中现在很少使用JNI，只有涉及到硬件资源的操作时才会使用</li><li>对于不同语言的程序间调用，采用Socket、WebServer、http…也更加方便</li></ul><h2 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h2><ul><li>线程私有</li><li>指向方法区中的方法字节码</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul><li>所有线程共享的区域，所有定义的方法的信息都保存在该区域</li><li>静态变量、常量、类信息（静态方法、构造方法、接口定义）、运行时的常量池都存在方法区当中</li><li>实例变量存在堆内存中，和方法区无关<br><img src="image_20200713174306.png"></li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li>存放8大基本类型和对象引用</li><li>栈不存在垃圾回收问题</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li>一个JVM只有一个堆内存，大小可以调节。当堆内存用完后会出现OOM错误</li><li>堆内存中细分三个区域<ul><li>新生区（伊甸园、幸存0区、幸存1区）</li><li>老年区</li><li>永久区（现在堆中没有永久区了，改为使用==元空间==代替原来的功能）</li></ul></li><li>Java程序的调优，就是在“伊甸园”和“老年区”中进行垃圾回收</li><li>在新生区是“轻GC”，在老年区是“重GC”</li></ul><h3 id="新生区-Young"><a href="#新生区-Young" class="headerlink" title="新生区(Young)"></a>新生区(Young)</h3><ul><li>对象诞生、成长甚至死亡的地方</li><li>伊甸园（Eden）：所有的对象都是在伊甸园new出来的</li><li>幸存者区(0,1)：在伊甸园没有被“轻GC”清理掉的对象，分（from、to）两个区域</li><li>经过研究，绝大部分的对象都是临时对象，在新生区就会被清理回收</li></ul><h3 id="老年区-Old"><a href="#老年区-Old" class="headerlink" title="老年区(Old)"></a>老年区(Old)</h3><ul><li>在幸存者区没有被清理的对象会进入老年区</li><li>当老年区满了之后，“重GC”会对其进行内存的清理</li></ul><h3 id="永久区-Meta"><a href="#永久区-Meta" class="headerlink" title="永久区(Meta)"></a>永久区(Meta)</h3><ul><li>在JDK1.8之后是已经没有永久代了，已经变成了元空间</li><li>这个区域是常驻内存的，用来存放Java的一些运行时环境、自身携带的Class对象、interface元数据~</li><li>这个区域不存在垃圾回收的问题，和OOM没有关系</li><li>关闭JVM虚拟机才会释放这块内存</li><li>元空间（MetaSpace）逻辑上存在，物理上不存在</li></ul><h3 id="OOM错误"><a href="#OOM错误" class="headerlink" title="OOM错误"></a>OOM错误</h3><ul><li>出现这种错误，首先要尝试扩大堆内存。通过为JVM传入参数来设定分配的内存大小</li><li>然后分析内存，使用工具查看堆中的使用情况</li><li>内存快照分析工具：MAT、Jprofiler</li><li>工具的作用<ul><li>分析Dump内存文件，快速定位内存泄露</li><li>获得堆中的数据</li><li>获取堆中占用空间最大的对象</li><li>……</li></ul></li><li>JVM参数<ul><li><code>-Xms[size]</code>：设置初始化内存分配大小</li><li><code>-Xmx[size]</code>：设置最大分配内存</li><li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：当发生堆内存溢出时，生成Dump文件</li><li><code>-XX:+PrintGCDetails</code>：命令行打印堆的使用情况</li></ul></li></ul><h2 id="垃圾回收器-GC"><a href="#垃圾回收器-GC" class="headerlink" title="垃圾回收器 (GC)"></a>垃圾回收器 (GC)</h2><ul><li>GC 的作用区域只在堆和方法区当中</li></ul><h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><ol><li>引用计数法</li><li>复制算法<ul><li>在幸存者区中，从from到to不断复制对象</li><li>这种方法没有内存碎片，但是需要额外的一半空间</li><li>当经历了15次(默认值)复制依然没有被回收的对象会进入老年区</li><li>通过<code>-XX:MaxTenuringThreshold=[复制次数]</code>来手动设定进入老年区的复制次数限制</li></ul></li><li>标记压缩清除算法<ul><li>两次扫描严重浪费时间，同时在清理时会留下内存碎片</li><li>通过压缩的方法移动对象的存储位置，减少内存空间的碎片浪费问题</li></ul></li></ol><h2 id="JMM-Java-Memory-Model"><a href="#JMM-Java-Memory-Model" class="headerlink" title="JMM (Java Memory Model)"></a>JMM (Java Memory Model)</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java8 新特性</title>
    <link href="/2020/10/24/Java8-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2020/10/24/Java8-%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h1><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><h1 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h1><h1 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JUC并发编程</title>
    <link href="/2020/10/23/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/10/23/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h1><ul><li>就是Java工具包中的三个包<ul><li><code>java.util.concurrent</code></li><li><code>java.util.concurrent.atomic</code></li><li><code>java.util.concurrent.locks</code></li></ul></li></ul><h2 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程/线程"></a>进程/线程</h2><ul><li>Java默认有两个线程：<code>main</code> &amp; <code>GC</code></li><li>Java是无法直接开启线程的，需要通过<code>native</code>调用本地方法（底层C++）</li><li>并发编程本质：<strong>充分利用CPU资源</strong><h3 id="代码查看CPU核"><a href="#代码查看CPU核" class="headerlink" title="代码查看CPU核"></a>代码查看CPU核</h3></li><li><code>Runtime.getRuntime().availableProcessors()</code></li><li>CPU密集型</li><li>IO密集型<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span> </span>&#123;    <span class="hljs-comment">// 新生</span>  NEW,      <span class="hljs-comment">// 运行</span>  RUNNABLE,      <span class="hljs-comment">// 阻塞</span>  BLOCKED,      <span class="hljs-comment">// 死等</span>  WAITING,      <span class="hljs-comment">// 超时等待</span>  TIMED_WAITING,      <span class="hljs-comment">// 终止</span>  TERMINATED;  &#125;</code></pre><h3 id="wait-sleep区别"><a href="#wait-sleep区别" class="headerlink" title="wait/sleep区别"></a><code>wait/sleep</code>区别</h3></li></ul><ol><li>来源不同的类<ul><li><code>wait</code> =&gt; <code>Object</code></li><li><code>sleep</code> =&gt; <code>Thread</code></li></ul></li><li>锁的释放<ul><li><code>wait</code>会释放锁</li><li><code>sleep</code>不释放锁</li></ul></li><li>使用范围不同<ul><li><code>wait</code>必须在同步代码块中</li><li><code>sleep</code>可以在任何地方使用</li></ul></li><li>捕获异常<ul><li><code>wait</code>不需要捕获异常</li><li><code>sleep</code>需要捕获异常</li></ul></li></ol><ul><li>使用<code>TimeUnit</code>类，如：<code>TimeUnit.SECONDS.sleep(12);</code><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><h3 id="传统Synchronized"><a href="#传统Synchronized" class="headerlink" title="传统Synchronized"></a>传统Synchronized</h3></li><li>同步方法</li><li>同步代码块</li></ul><h3 id="使用Lock锁"><a href="#使用Lock锁" class="headerlink" title="使用Lock锁"></a>使用Lock锁</h3><ul><li>在<code>java.util.concurrent.locks</code>包中</li><li>拥有三个实现类：<ul><li><code>ReentrantLock</code> ：可重入锁（常用）</li><li><code>ReadLock</code> ：读锁</li><li><code>WriteLock</code> ：写锁</li></ul></li><li>new一个<code>ReentrantLock</code>锁时，可以选则公平锁/非公平锁<ul><li>不传参默认生成非公平锁<code>Lock lock = new ReentrantLock();</code></li><li>传参true：公平锁</li><li>传参false：非公平锁</li></ul></li><li>在<code>lock.lock()</code>/<code>lock.tryLock()</code> &amp; <code>lock.unlock()</code>之间定义加锁大的代码块</li></ul><h3 id="Synchronized-amp-Lock的区别"><a href="#Synchronized-amp-Lock的区别" class="headerlink" title="Synchronized &amp; Lock的区别"></a><code>Synchronized</code> &amp; <code>Lock</code>的区别</h3><ul><li>前者是Java内置关键字；后者是一个类</li><li>前者无法判断获取锁的状态；后者可以</li><li>前者在运行结束后自动释放；后者需要手动完成</li><li>前者是固定的模式（可重入、不可中断、非公平）</li><li>前者适合少量的代码同步问题，后者适合大量的代码同步问题</li></ul><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="传统版"><a href="#传统版" class="headerlink" title="传统版"></a>传统版</h3><ul><li>在传统线程的通讯过程中，使用<code>synchronized</code>关键字配合<code>this.wait() &amp; this.notify/notifyAll()</code>这两个方法</li><li>使用过程中，当需要通过条件判断来决定是否进入<code>wait()</code>时，不要使用if语句来进行判断</li><li>这样会出现<strong>虚假唤醒</strong>的情况，即被唤醒之后依然不具备退出<code>wait()</code>的条件</li><li>所以要使用while语句来进行条件的判断，例如：<pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (obj) &#123;<span class="hljs-keyword">while</span> (&lt;condition&gt;)obj.wait();...<span class="hljs-comment">//TODO</span>obj.notifyAll();&#125;</code></pre><h3 id="JUC版"><a href="#JUC版" class="headerlink" title="JUC版"></a>JUC版</h3></li><li>在这个系列中，使用Lock对象来对代码进行互斥访问；配合<code>await() &amp; signal()</code>实现同步</li><li>首先生成一个条件<code>Condition condition = lock.newCondition();</code></li><li>然后调用同步方法<code>condition.await() &amp; condition.signalAll()</code><blockquote><p>使用Condition可以实现更加精准的同步问题</p></blockquote></li><li>对于同一个锁lock，可以同时生成多个condition</li><li>对于每一个单独的condition可以单独的进行<code>await() &amp; signal()</code>，以此实现精准控制<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data2</span> </span>&#123;      <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();   <span class="hljs-keyword">private</span> Condition condition1 = lock.newCondition();   <span class="hljs-keyword">private</span> Condition condition2 = lock.newCondition();   <span class="hljs-keyword">private</span> Condition condition3 = lock.newCondition();     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printA</span><span class="hljs-params">()</span> </span>&#123;          lock.lock();   <span class="hljs-keyword">try</span> &#123;              <span class="hljs-keyword">while</span> (number != <span class="hljs-number">1</span>)                  condition1.await();    System.out.println(Thread.currentThread().getName());    number = <span class="hljs-number">2</span>;    condition2.signal();    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;              e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;              lock.unlock();    &#125;      &#125;;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printB</span><span class="hljs-params">()</span> </span>&#123;          lock.lock();   <span class="hljs-keyword">try</span> &#123;              <span class="hljs-keyword">while</span> (number != <span class="hljs-number">2</span>)                  condition2.await();    System.out.println(Thread.currentThread().getName());    number = <span class="hljs-number">3</span>;    condition3.signal();    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;              e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;              lock.unlock();    &#125;      &#125;;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printC</span><span class="hljs-params">()</span> </span>&#123;          lock.lock();   <span class="hljs-keyword">try</span> &#123;              <span class="hljs-keyword">while</span> (number != <span class="hljs-number">3</span>)                  condition3.await();    System.out.println(Thread.currentThread().getName());    number = <span class="hljs-number">1</span>;    condition1.signal();    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;              e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;              lock.unlock();    &#125;      &#125;;  &#125;</code></pre></li></ul><h2 id="深入理解锁"><a href="#深入理解锁" class="headerlink" title="深入理解锁"></a>深入理解锁</h2><h3 id="1-synchronized锁的对象是方法的调用者"><a href="#1-synchronized锁的对象是方法的调用者" class="headerlink" title="1. synchronized锁的对象是方法的调用者"></a>1. <code>synchronized</code>锁的对象是方法的调用者</h3><ul><li>针对于被<code>synchronized</code>修饰的方法调用场景</li><li>被锁住的是调用该方法的实例对象（每个实例对象都有一个内部锁🔒）</li><li>对于那些没有<code>synchronized</code>修饰的方法，则不会受到锁的限制，任意调用</li><li>对于两个实例对象，对两个对象分别调用有锁的方法时，相互之间是不影响的（因为锁的是不同的对象）<h3 id="2-static-amp-synchronized-同时修饰的方法锁的是Class"><a href="#2-static-amp-synchronized-同时修饰的方法锁的是Class" class="headerlink" title="2. static &amp; synchronized 同时修饰的方法锁的是Class"></a>2. <code>static</code> &amp; <code>synchronized</code> 同时修饰的方法锁的是Class</h3></li><li>静态的方法在上锁时，是对这个类的Class进行加锁的</li><li>所以在调用同类不同对象的静态有锁方法时，相互之间会受影响</li></ul><h2 id="集合类不安全"><a href="#集合类不安全" class="headerlink" title="集合类不安全"></a>集合类不安全</h2><ul><li>并发操作集合时，会出现<code>ConcurrentModificationException</code> ==并发修改异常==<h3 id="List类不安全"><a href="#List类不安全" class="headerlink" title="List类不安全"></a>List类不安全</h3><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4></li></ul><ol><li>使用Vector代替ArrayList，Vector默认就是多线程安全的集合</li><li>JDK提供了将非安全集合转换为安全集合的方法<code>List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</code></li><li>JUC有单独的多线程安全集合实现：<code>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</code></li></ol><h4 id="COW-写入时复制"><a href="#COW-写入时复制" class="headerlink" title="COW 写入时复制"></a>COW 写入时复制</h4><ul><li>CopyOnWrite 技术是计算机程序设计领域的一种优化策略</li><li>当多个线程同时调用一个List对其进行写入时，先复制一份给调用者进行写入，再回传给List</li><li>这样来避免在写入时覆盖的问题</li><li>==读写分离==</li><li>COW技术比Vector这样的使用synchronized的方法更加高效</li></ul><h3 id="Set类不安全"><a href="#Set类不安全" class="headerlink" title="Set类不安全"></a>Set类不安全</h3><ul><li>和List的实现方式类似<h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4></li></ul><ol><li>JDK提供的安全类转换接口<code>Set&lt;String&gt; ser = Collections.synchronizedSet(new HashSet&lt;&gt;());</code></li><li>JUC提供的多线程安全结合实现：<code>Set&lt;String&gt; ser = new CopyOnWriteArraySet&lt;&gt;();</code><h4 id="HashSet的底层实现"><a href="#HashSet的底层实现" class="headerlink" title="HashSet的底层实现"></a>HashSet的底层实现</h4></li></ol><ul><li>HashSet底层是用HashMap实现的，利用了Map的key不重复的特点</li><li>对于HashSet的很多方法也是直接调用了HashMap的方法来进行的</li></ul><h3 id="Map类不安全"><a href="#Map类不安全" class="headerlink" title="Map类不安全"></a>Map类不安全</h3><h4 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h4><ol><li>JDK提供的安全类转换接口<code>Map&lt;String,String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</code></li><li>JUC提供的多线程安全结合实现：<code>Map&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;();</code></li></ol><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><ul><li>和Runnable接口是类似的，不过多了返回值的功能</li><li>不能直接由Thread调用这个函数式接口，而需要一个中间类<pre><code class="hljs java">FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(<span class="hljs-keyword">new</span> MyThread());  <span class="hljs-keyword">new</span> Thread(futureTask).start();  String str = (String) futureTask.get();</code></pre></li><li>注意：<ul><li>有缓存</li><li>结果获得可能需要等待，<code>get()</code>方法会阻塞</li></ul></li></ul><h2 id="常用辅助类"><a href="#常用辅助类" class="headerlink" title="常用辅助类"></a>常用辅助类</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><ul><li>一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助</li><li><code>CountDownLatch countDownLatch = new CountDownLatch(6);</code></li><li><code>countDownLatch.countDown()</code> 数量 -1</li><li><code>countDownLatch.await()</code> 一直阻塞到数字减为0再重新开始执行</li><li>特点：一个线程发生阻塞，等到多个线程执行完成之后再执行<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3></li><li>一组线程全部等待彼此达到==共同屏障==点的同步辅助</li><li><code>CyclicBarrier cyclicBarrier = new CyclicBarrier(6,()-&gt;&#123;System.out.println(&quot;close&quot;);&#125;);</code></li><li><code>cyclicBarrier.await();</code></li><li>特点：多个线程发生阻塞之后，等待CyclicBarrier指定的线程进行执行之后再执行<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3></li><li>信号量</li><li><code>Semaphore semaphore = new Semaphore(3);</code> </li><li><code>semaphore.acquire();</code> 获取一个资源，没有时会阻塞等待</li><li><code>semaphore.release();</code> 释放一个资源，唤醒阻塞的线程</li><li>限制资源使用的方法</li></ul><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ul><li><code>ReadWriteLock</code> 接口</li><li><code>ReentrantReadWriteLock</code> 是其唯一实现类</li><li>这个类中有两个锁，分别用于读写</li><li>读写锁保证可以让多个线程同时读出，但是只能允许一个线程同时写入</li></ul><table><thead><tr><th>读锁</th><th>写锁</th></tr></thead><tbody><tr><td>共享锁</td><td>独占锁</td></tr></tbody></table><ul><li><code>ReadWriteLock lock = new ReentrantReadWriteLock()</code></li><li><code>lock.readLock().lock()</code></li><li><code>lock.readLock().unlock()</code></li><li><code>lock.writeLock().lock()</code></li><li><code>lock.writeLock().unlock()</code> </li></ul><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><ul><li><code>BlockingQueue</code>接口 </li><li>实现类：<code>ArrayBlockingQueue</code> <code>LinkedBlockingQueue</code> (这两个用法相似) ；<code>SynchronousQueue</code> (这个实现类的队列空间只有一个)</li><li><code>ArrayBlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</code><h4 id="四组API"><a href="#四组API" class="headerlink" title="四组API"></a>四组API</h4></li></ul><table><thead><tr><th>方式</th><th>抛出异常</th><th>返回值，不抛出异常</th><th>阻塞等待</th><th>超时等待</th></tr></thead><tbody><tr><td>添加</td><td>add</td><td>offer</td><td>put</td><td>offer</td></tr><tr><td>移除</td><td>remove</td><td>poll</td><td>take</td><td>poll</td></tr><tr><td>检测队首</td><td>element</td><td>peek</td><td>/</td><td>/</td></tr></tbody></table><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><strong>三大方法、七大参数、四种拒绝策略</strong></p><blockquote><p>池化技术：对系统资源使用的优化 </p></blockquote><ul><li>线程池、连接池、内存池、对象池</li><li>事先准备好一些资源，要用就从池中获取，用完之后再归还。</li><li>减少资源使用过程中的浪费，资源的创建、销毁都很耗时<h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3></li></ul><ol><li>线程复用，降低资源消耗提高相应速度</li><li>可控最大并发数</li><li>方便管理线程<h3 id="三大创建线程池的方法"><a href="#三大创建线程池的方法" class="headerlink" title="三大创建线程池的方法"></a>三大创建线程池的方法</h3><pre><code class="hljs java">ExecutorService threadPool = Executors.newSingleThreadExecutor(); <span class="hljs-comment">// 单个线程池  </span>ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>); <span class="hljs-comment">// 创建固定大小的线程池  </span>ExecutorService threadPool = Executors.newCachedThreadPool(); <span class="hljs-comment">// 大小可伸缩的线程池</span></code></pre><h3 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h3></li></ol><ul><li>在使用三大方法创建线程池时，其底层都调用了同一个函数<code>ThreadPoolExecutor()</code></li><li>这个底层调用的函数拥有7个参数<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,  // 核心线程池大小</span></span><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">int</span> maximumPoolSize,  //最大核心线程池大小</span></span><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">long</span> keepAliveTime,  //超时没有人调用就会释放</span></span><span class="hljs-function"><span class="hljs-params">  TimeUnit unit,  //超时单位</span></span><span class="hljs-function"><span class="hljs-params">  BlockingQueue&lt;Runnable&gt; workQueue,  //阻塞队列</span></span><span class="hljs-function"><span class="hljs-params">  ThreadFactory threadFactory,  //线程工厂</span></span><span class="hljs-function"><span class="hljs-params">  RejectedExecutionHandler handler)</span> </span>&#123;  <span class="hljs-comment">//拒接策略</span><span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||      maximumPoolSize &lt;= <span class="hljs-number">0</span> ||      maximumPoolSize &lt; corePoolSize ||      keepAliveTime &lt; <span class="hljs-number">0</span>)      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();   <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();   <span class="hljs-keyword">this</span>.acc = System.getSecurityManager() == <span class="hljs-keyword">null</span> ?              <span class="hljs-keyword">null</span> :              AccessController.getContext();   <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;   <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;   <span class="hljs-keyword">this</span>.workQueue = workQueue;   <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);   <span class="hljs-keyword">this</span>.threadFactory = threadFactory;   <span class="hljs-keyword">this</span>.handler = handler;  &#125;</code></pre><img src="image_20200725232042.png"></li><li>手动调用底层函数创建线程池举例<pre><code class="hljs java">ExecutorService threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(  <span class="hljs-number">2</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">2</span>,  TimeUnit.SECONDS,  <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>),  Executors.defaultThreadFactory(),  <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());</code></pre><h3 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h3></li><li>对应<code>RejectedExecutionHandler</code>接口的四个实现类</li></ul><ol><li><code>new ThreadPoolExecutor.AbortPolicy()</code> 队列溢出时，不处理这个任务并抛出异常</li><li><code>new ThreadPoolExecutor.CallerRunsPolicy()</code> 哪来的去哪里，让原线程去执行这个线程</li><li><code>new ThreadPoolExecutor.DiscardOldestPolicy()</code> 会尝试去竞争最早的线程，如果没有执行完成，依然会被抛掉</li><li><code>new ThreadPoolExecutor.DiscardPolicy()</code> 不执行这个任务，但不抛出异常</li></ol><h3 id="最大线程数定义办法"><a href="#最大线程数定义办法" class="headerlink" title="最大线程数定义办法"></a>最大线程数定义办法</h3><h4 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h4><ul><li>最大核心数定义为：<code>Runtime.getRuntime().availableProcessors()</code><h4 id="I-O-密集型"><a href="#I-O-密集型" class="headerlink" title="I/O 密集型"></a>I/O 密集型</h4></li><li>判断程序中十分耗I/O的线程数量，然后取 2N</li></ul><h2 id="⭐四大函数式接口"><a href="#⭐四大函数式接口" class="headerlink" title="⭐四大函数式接口"></a>⭐四大函数式接口</h2><blockquote><p>新时代Java技术：lambda表达式、链式编程、函数式接口、Stream流式计算</p></blockquote><h3 id="1-Function"><a href="#1-Function" class="headerlink" title="1. Function"></a>1. <code>Function</code></h3><ul><li>有输入参数和返回值<pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;        <span class="hljs-comment">/**  </span><span class="hljs-comment"> * Applies this function to the given argument. * * <span class="hljs-doctag">@param</span> t the function argument  </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the function result  </span><span class="hljs-comment"> */</span>  <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;</code></pre><h3 id="2-Predicate"><a href="#2-Predicate" class="headerlink" title="2. Predicate"></a>2. <code>Predicate</code></h3></li><li>有输入输出参数，但是输出参数类型指定为<code>boolean</code><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;        <span class="hljs-comment">/**  </span><span class="hljs-comment"> * Evaluates this predicate on the given argument. * * <span class="hljs-doctag">@param</span> t the input argument  </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if the input argument matches the predicate,  </span><span class="hljs-comment"> * otherwise &#123;<span class="hljs-doctag">@code</span> false&#125;  </span><span class="hljs-comment"> */</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;</code></pre><h3 id="3-Consumer"><a href="#3-Consumer" class="headerlink" title="3. Consumer"></a>3. <code>Consumer</code></h3>只有一个输入参数，没有输出参数<pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;        <span class="hljs-comment">/**  </span><span class="hljs-comment"> * Performs this operation on the given argument. * * <span class="hljs-doctag">@param</span> t the input argument  </span><span class="hljs-comment"> */</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;</code></pre><h3 id="4-Supplier"><a href="#4-Supplier" class="headerlink" title="4. Supplier"></a>4. <code>Supplier</code></h3></li><li>只有一个输出参数而没有输入参数<pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;        <span class="hljs-comment">/**  </span><span class="hljs-comment"> * Gets a result. * * <span class="hljs-doctag">@return</span> a result  </span><span class="hljs-comment"> */</span>  <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;  &#125;</code></pre></li></ul><h2 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h2><ul><li>Stream是操作集合的一种计算工具，它大大提高了编程、计算的效率</li><li>程序可以拆分为：存储数据的集合 与 进行计算的流</li><li>一个集合所形成的流在运算中只会遍历一次</li><li>在流水线中，一旦一个元素走完了流水线，那么这个元素就被“消费”掉了不能再对这个流进行操作</li><li>流处理的方式是采用内部迭代，手动处理集合的则是外部迭代<h3 id="流的操作种类"><a href="#流的操作种类" class="headerlink" title="流的操作种类"></a>流的操作种类</h3><h4 id="1-中间操作-Intermediate"><a href="#1-中间操作-Intermediate" class="headerlink" title="1. 中间操作 Intermediate"></a>1. 中间操作 Intermediate</h4>操作方法：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</li><li>数据在流水线过程中，所受到的所有操作都是“中间操作”</li><li>输入输出的方式都是==流==对象，以此串连形成一个流水线<h4 id="2-终端操作-Terminal"><a href="#2-终端操作-Terminal" class="headerlink" title="2. 终端操作 Terminal"></a>2. 终端操作 Terminal</h4>操作方法：forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</li><li>执行完“中间操作”之后需要用“终端操作”将数据从流水线上拿下来<h3 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h3></li></ul><ol><li>从Collection的实现类中获取流<code>Stream&lt;Student&gt; streamStd = list.stream();</code></li><li>从数组中获取流<code>Stream&lt;Student&gt; streamStr = Arrays.stream(students);</code><h3 id="过滤器-filter"><a href="#过滤器-filter" class="headerlink" title="过滤器 filter"></a>过滤器 filter</h3></li></ol><ul><li>使用的是<code>Predicate</code>函数式接口：<code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</code></li><li>传入的参数为流中的基本元素对象，筛选出返回值为<code>true</code>的元素<h3 id="去重-distinct"><a href="#去重-distinct" class="headerlink" title="去重 distinct"></a>去重 distinct</h3></li><li>去掉重复的结果，直接调用<code>list.stream().distinct()</code><h3 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h3></li><li>截取流中的前n个元素<code>list.stream().limit(3)</code><h3 id="跳过"><a href="#跳过" class="headerlink" title="跳过"></a>跳过</h3></li><li>跳过流的前n个元素<code>list.stream().skip(3)</code><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3></li><li>流中元素的类型会发生变化，所以是将原来的对象映射为另一种对象<code>list.stream().map(Person::getName)</code><h3 id="合并流"><a href="#合并流" class="headerlink" title="合并流"></a>合并流</h3></li><li>用<code>flagmap()</code>代替<code>map()</code><h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2></li></ul><h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><ul><li>虚拟机提供的轻量级的同步机制：<ol><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ol></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE</title>
    <link href="/2020/10/22/JavaSE/"/>
    <url>/2020/10/22/JavaSE/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><p>最后更新：2020.7.10<br><img src="01.png" alt="输入图片描述"></p><h2 id="Java-三大版本"><a href="#Java-三大版本" class="headerlink" title="Java 三大版本"></a>Java 三大版本</h2><ul><li>JavaSE    桌面端</li><li><del>JavaME 移动端</del></li><li>JavaEE Web端/服务器<h2 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK / JRE / JVM"></a>JDK / JRE / JVM</h2><img src="http://codingfox.com/wp-content/uploads/2014/11/jdk-doc.png" alt="输入图片描述"><h1 id="👉Java基础"><a href="#👉Java基础" class="headerlink" title="👉Java基础"></a>👉Java基础</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2></li><li>基本类型<ul><li>数值<ul><li>整数：byte、short、int、long</li><li>浮点：float、double</li></ul></li><li>字符：char        (Java使用的Unicode，占用2个字节)</li><li>布尔：boolean    (占一位，取值只有<code>true</code>&amp;<code>false</code>)</li></ul></li><li>引用类型<blockquote><p>类型拓展</p></blockquote></li><li>不使用浮点数进行比较，转而使用一个BigDecimal的类来表示浮点数</li><li>基本类型都有对应的方法类，如：Integer、Short、Long……（静态，属于工具类）</li><li>数字可以使用下划线进行分割 <code>int a = 10_000_000;</code><blockquote><p>类型转换</p></blockquote></li><li>类型顺序：低 —————————-&gt; 高<br><code>byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</code></li><li>低 -&gt; 高：自动类型转换</li><li>高 -&gt; 低：强制类型转换</li><li><code>char</code>类型在进行赋值时都需要强制转换<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></li><li>局部变量<ul><li>必须有初始化值</li><li>存在且只在当前的方法和代码块中起作用</li></ul></li><li>实例变量<ul><li>存在于类，但是需要实例化的变量。属于每个实例</li><li>可以不用赋初始值，会自动设置为默认值<code>0 或者 null 或者 false</code></li></ul></li><li>类变量<ul><li>属于类的变量，有<code>static</code>修饰</li><li>不会受实例化对象的影响<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2></li></ul></li><li>存在于类当中，不能被修改</li><li><code>static final</code>修饰<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2></li><li>这里只提一下<code>+</code>在字符串拼接中的用法</li><li>Java中的<code>+</code>在数值运算和字符串的拼接中都有意义</li><li>当其两侧都是数值时就是==加==，当两侧存在String时就是==拼接==<pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">12</span>;  <span class="hljs-keyword">int</span> b = <span class="hljs-number">30</span>;  System.out.println(<span class="hljs-string">&quot;&quot;</span>+a+b);  System.out.println(a+b+<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//输出结果</span><span class="hljs-number">1230</span><span class="hljs-number">42</span></code></pre><h1 id="👉Java流程控制"><a href="#👉Java流程控制" class="headerlink" title="👉Java流程控制"></a>👉Java流程控制</h1></li><li>Scanner对象<pre><code class="hljs java">Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);in.hasNext();<span class="hljs-comment">//return boolean</span>in.next();<span class="hljs-comment">//return 指明的类型（String、int、float……）</span>in.hasNext~();in.next~();</code></pre></li><li>if选择语句</li><li>switch选择语句</li><li>while循环语句</li><li>for循环语句<pre><code class="hljs java"><span class="hljs-comment">//增强型的for，主要用于数组、集合</span><span class="hljs-keyword">int</span>[] set = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">20</span>];  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i:set)&#123;&#125;</code></pre></li><li>break、continue、goto <ul><li>Java语法中goto语句并没有任何用处，只是作为了保留字</li><li>只有一个标签的使用方式，和C语言中goto的用法是相同的<pre><code class="hljs java">label:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i:set)&#123;      <span class="hljs-keyword">continue</span> label;  &#125;</code></pre><h1 id="👉Java方法"><a href="#👉Java方法" class="headerlink" title="👉Java方法"></a>👉Java方法</h1></li></ul></li><li>方法重载：相同函数名，不同参数</li><li>可变参数的方法<ul><li>指定参数后面加省略号(…)</li><li>一个方法只能有一个可变参数，并且要是方法的最后一个参数</li><li>本质是使用了数组<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span>... b)</span></span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i:b)&#123;          System.out.println(i);    &#125;  &#125;</code></pre><h1 id="👉Java数组"><a href="#👉Java数组" class="headerlink" title="👉Java数组"></a>👉Java数组</h1></li></ul></li><li>数组是引用类型</li><li>像数组这样的引用类型，其new出来的对象都是存储在堆区的</li><li>其它的基本类型和引用类型的“指针”都在栈区</li><li>有对应的方法类：Arrays（静态，属于工具类）<h1 id="👉面向对象"><a href="#👉面向对象" class="headerlink" title="👉面向对象"></a>👉面向对象</h1></li><li>三大特性：封装、继承、多态</li><li>方法的特性：<ul><li>静态方法 –&gt; static修饰，通过类来调用</li><li>非静态方法 –&gt; 没有static修饰，通过对象来调用</li></ul></li><li>this关键字使用：指明是本对象中的属性</li><li>构造器<ul><li>没有声明构造器时，默认存在一个无参的构造器</li><li>构造器是无参数（底层返回的示例对象地址），没有返回类型的函数</li><li>在new时本质就是调用的构造器，用于初始化对象的函数</li></ul></li><li>==封装==<ul><li>属性私有：使用<code>private</code>关键字修饰类的属性</li><li>不能直接通过对象来访问修改这些属性，而需要用一些向外部提供的方法(<code>get/set</code>)来访问</li><li>这样很好的提供了数据的底层封装，保证了数据的安全性</li></ul></li><li>==继承==<ul><li>通过关键字<code>extands</code>来继承父类的所有属性和方法</li><li>使用<code>private</code>修饰的属性是没有办法在子类中访问的<br><img src="JavaSE_md_files/image_20200626090339.png?v=1&type=image&token=V1:xYIwWoVLp__-eFUV7bM4z1-lvjUqKKC67NELh2Cif2E"></li></ul></li><li><code>super-this</code>关键字<ul><li>对于子类的构造器，默认会调用父类的无参构造方法<code>super()</code></li><li>并且这个父类的方法，必须在子类构造方法的第一行</li><li><code>super()</code>和<code>this()</code>两个方法不能同时调用</li><li>通过这两个关键字可以指定访问父类和子类中的属性</li></ul></li><li>重写<ul><li>子类中的方法，可以重写父类中的方法</li><li>方法名和参数列表必须相同</li><li>修饰符：范围可以扩大但不能缩小</li><li>抛出异常：范围可以缩小但不能放大</li></ul></li><li>==多态==<ul><li>动态编译，是可扩展性更强</li><li>实现方式：将父类的引用指向子类实例对象（注意，不要倒过来将父类的引用指向子类实例对象）</li><li>父类的引用指向子类的实例时，由于方法的重写，将会调用子类的方法，这就实现了<strong>多态</strong></li><li>但是对于<code>static</code>的方法，只由引用的类型来决定，所以调用的方法来自于父类 </li></ul></li><li><code>instanceof</code>关键字：用于检查对象是否在继承链条当中</li><li>类型转换<ul><li>将子类型转换为父类型，像上转型、默认转换。</li><li>将父类型转换为子类型，向下转型、强制转换。但是会丢失一部分的方法</li></ul></li><li><code>static</code>关键字<ul><li>静态变量（类变量）</li><li>静态方法</li><li>代码块<ul><li>静态代码块：最先调用的代码块，并且只再第一次new时调用一次</li><li>匿名代码块：静态代码块调用之后，调用匿名代码块。每次new一个新的实例时都会执行这个代码块</li><li>以上两者执行之后再开始调用构造方法</li></ul></li><li>静态导入包：在<code>import</code>包时，使用<code>static</code>修饰之后，调用静态类方法时，不用指明类名，可以直接调用方法(函数)</li></ul></li><li>抽象类：使用<code>abstract</code>修饰的类<ul><li>抽象类中可以有普通的方法，抽象的方法需要使用<code>abstract</code>关键词修饰</li><li>而抽象方法，必须写到抽象类当中</li><li>抽象类的方法，必须要通过子类来实现；同时抽象类也必须要通过继承后，才能实例化</li></ul></li><li>接口：只有规范和约束<ul><li>接口需要有一个实现类；<code>implements</code>关键词来从重写接口中的方法</li><li>接口中的方法，默认有<code>public abstract</code>关键字</li><li>接口中变量，默认有<code>public static final</code>关键字。也就是说接口中的变量都是静态常量</li></ul></li><li>内部类：在外部类中声明的一个类，叫做内部类<ul><li>静态内部类</li><li>局部内部类：写在方法中的内部类</li><li>匿名内部类<h1 id="👉枚举类"><a href="#👉枚举类" class="headerlink" title="👉枚举类"></a>👉枚举类</h1></li></ul></li><li>枚举类不继承自<code>Object</code>，而是继承自<code>java.lang.Enum</code>类</li><li>枚举的一个重要特性是，不能通过反射获得，这与后面实现单例模式有很大的关系<h1 id="👉异常"><a href="#👉异常" class="headerlink" title="👉异常"></a>👉异常</h1></li><li>错误(Error)和异常(Exception)</li><li>有一个重要的子类是运行时异常，由编码造成的</li><li>其余是非运行时异常</li><li>捕获异常时一定要从小到大来进行捕获<h3 id="主动抛出异常"><a href="#主动抛出异常" class="headerlink" title="主动抛出异常"></a>主动抛出异常</h3></li><li>通过throw来进行主动抛出异常，一般在方法中使用。但是这里主动抛出了异常，就需要我们去捕获处理</li><li>如果在本方法中不能捕获处理这个异常，那么就需要使用<code>throws</code>将这个异常在方法上抛出，让外层调用时捕获处理这个异常<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3></li><li>定义一个异常类，需要继承<code>Exception</code><h1 id="👋常用类"><a href="#👋常用类" class="headerlink" title="👋常用类"></a>👋常用类</h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2></li><li>所有类的父类，结构层次中的根类<h3 id="重要的方法"><a href="#重要的方法" class="headerlink" title="重要的方法"></a>重要的方法</h3></li><li><code>toString()</code><ul><li>直接打印对象的名字就是调用的<code>toString()</code>的返回结果</li><li>这个方法默认是打印<code>hashCode()</code>，所以一般是需要重写<code>toString()</code>方法的</li></ul></li><li><code>equals()</code><ul><li>用来比较引用类型是否指向同一个对象，也就是比较的<code>hashCode()</code></li><li>但是我们一般是需要比较对象的属性是否相同的，所以也需要重写<code>equals()</code>方法</li><li>由于<code>equals()</code>方法的传入参数是Object类的对象，多态的特性使其不能访问子类的属性，所以这里需要强行向下转型<h3 id="Objects工具类"><a href="#Objects工具类" class="headerlink" title="Objects工具类"></a>Objects工具类</h3></li></ul></li><li><code>Objects.equals(Object a, Object b)</code> : 这个方法的底层依然会调用<code>a.equals(b)</code>，但是在a为<code>null</code>时，可以避免返回异常</li></ul><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="“-”连接符"><a href="#“-”连接符" class="headerlink" title="“+”连接符"></a>“+”连接符</h3><ul><li>本质上是通过<code>StringBuffer</code>或者<code>StringBuilder</code>类的<code>append()</code>方法来实现的</li><li>每次调用的<code>+</code>连接符都会去<code>new</code>一个新的<code>StringBuilder</code>对象来完成字符串的拼接，然后在通过<code>toString()</code>将其类型转换成<code>String</code>类型</li><li>所以当我们在进行循环里面的字符串拼接时，要手动创建<code>StringBuilder</code>来进行拼接，避免每一次循环都要<code>new</code>新的对象，还用转换成<code>String</code>类型<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3></li><li>在Java的内存分配中，总共3种常量池，分别是<strong>Class常量池</strong>、<strong>运行时常量池</strong>、<strong>字符串常量池</strong></li><li>JVM针对字符串的实例化做了优化：每当创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中</li><li>这样的优化是针对于<code>String str = &quot;hello&quot;</code>这样的直接赋值方式</li><li>但是直接通过构造方法声明的话<code>String str= new String(&quot;hello&quot;)</code>是直接在堆内存中创建对象，就不会有优化的功能，相同的字符串创建的对象在堆内存中不是同一个对象</li><li><code>String</code>类提供了一个将声明在堆中的<code>String</code>对象转换为字符串常量池中的对象的方法：<code>String::intern</code><h3 id="StringBuffer-amp-StringBuilder"><a href="#StringBuffer-amp-StringBuilder" class="headerlink" title="StringBuffer &amp; StringBuilder"></a>StringBuffer &amp; StringBuilder</h3><img src="image_20201027152600.png"></li></ul><h1 id="👋IO"><a href="#👋IO" class="headerlink" title="👋IO"></a>👋IO</h1><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><ul><li>这是一个与操作系统无关的类，在任何操作系统下都可以运行</li><li>使用这个类可以进行一些文件相关的操作：<ul><li>创建文件/文件夹</li><li>删除文件/文件夹</li><li>获取文件/文件夹</li><li>判断文件/文件夹是否存在</li><li>对文件夹进行遍历</li><li>获取文件大小<h3 id="File的静态成员变量"><a href="#File的静态成员变量" class="headerlink" title="File的静态成员变量"></a>File的静态成员变量</h3></li></ul></li><li>路径分隔符：<code>File.pathSeparator</code><ul><li>Windows：<code>;</code></li><li>Linux：<code>:</code></li></ul></li><li>名称分隔符：<code>File.separator</code><ul><li>Windows：<code>\</code></li><li>Linux：<code>/</code><h3 id="File的构造方法"><a href="#File的构造方法" class="headerlink" title="File的构造方法"></a>File的构造方法</h3></li></ul></li></ul><ol><li>以字符串的形式，直接传入文件/文件夹的路径</li><li>将路径分成<code>parent</code>和<code>child</code>两部分，都以字符串的形式表示</li><li>路径分成<code>parent</code>和<code>child</code>两部分，但是<code>parent</code>是File类型的<h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3></li></ol><ul><li><code>public String getAbsolutePath()</code>：返回文件的绝对路径</li><li><code>public String getPath()</code>：获取文件的路径，具体和创建时的输入路径有关（可能绝对、可能相对）</li><li><code>public String getName()</code>：返回文件/文件夹的名字</li><li><code>public long length()</code>：返回文件的字节长度，对文件夹和找不到的文件都返回<code>0</code><h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3></li><li><code>public boolean exists()</code>：文件/文件夹是否存在？</li><li><code>public boolean isDirectory()</code>：是否是文件夹？</li><li><code>public boolean isFile()</code>：是否是文件？<h3 id="创建删除方法"><a href="#创建删除方法" class="headerlink" title="创建删除方法"></a>创建删除方法</h3></li><li><code>public boolean createNewFile()</code>：创建File对象所指明的文件。文件已经存在、文件的路径不存在都会导致创建失败，报出异常</li><li><code>public boolean mkdir()</code>：创建单级文件夹。文件夹已存在或者路径不存在时，创建失败返回<code>false</code></li><li><code>public boolean mkdirs()</code>：创建多级文件夹，一般都用这个</li><li><code>public boolean delete()</code>：删除文件或者文件夹。当文件/文件夹不存在时，返回<code>false</code>；当文件夹中有内容时，不会删除并返回<code>false</code><h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3></li><li><code>public String[] list()</code>：返回目录下的文件/文件夹名集合</li><li><code>public File[] listFiles()</code>：返回目录下的文件/文件夹的File对象集合<h3 id="文件过滤器"><a href="#文件过滤器" class="headerlink" title="文件过滤器"></a>文件过滤器</h3></li><li><code>FileFilter</code>接口，实现<code>public boolean accept(File pathname)</code>方法</li><li><code>FilenameFilter</code>接口，实现<code>public boolean accept(File dir, String name)</code>方法</li><li>将两种接口的实现类对象作为参数传递给<code>list()</code>或<code>listFiles()</code>方法<h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><table><thead><tr><th></th><th>输入流</th><th>输出流</th></tr></thead><tbody><tr><td>字节流</td><td><code>InputStream</code></td><td><code>OutputStream</code></td></tr><tr><td>字符流</td><td><code>Reader</code></td><td><code>Writer</code></td></tr></tbody></table></li><li>顶层的四个流的父类</li><li>计算机中的所有文件都是以字节来存储的，所以传输过程中也是以字节来进行传输<h3 id="OutputStream类"><a href="#OutputStream类" class="headerlink" title="OutputStream类"></a>OutputStream类</h3></li><li>所有字节输出流的父类</li><li>通用方法：<ol><li>   <code>void close()</code></li><li>   <code>void flush()</code>：刷新此输出流并强制任何缓冲的输出字节被写出</li><li>   <code>void write(byte[] b)</code>：将 <code>b.length</code>字节从指定的字节数组写入此输出流</li><li>   <code>void write(byte[] b, int off, int len)</code>：从指定的字节数组写入 <code>len</code>个字节，从偏移 <code>off</code>开始</li><li>   <code>abstract void write(int b)</code>：将指定的字节写入此输出流</li></ol></li></ul><h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a><em>FileOutputStream</em></h4><ul><li>构造方法传参<code>String name</code>或者<code>File file</code></li><li>构造方法传入参数<code>boolean append</code>为<code>true</code>，代表文件内容追加；默认为<code>false</code>代表覆盖写入</li><li>调用<code>write()</code>方法写入数据时，需要将字符串转换为Byte流，使用方法<code>string.getBytes()</code>进行转换<h3 id="InputStream类"><a href="#InputStream类" class="headerlink" title="InputStream类"></a>InputStream类</h3></li><li>所有字节输入流的父类</li><li>通用方法<ol><li><code>int read()</code>：读取一个字节并直接返回，结尾返回-1</li><li><code>int read(byte[] b)</code>：读取一定数量的字节数，并存储在缓冲区数组中，返回值int表示读取的字节数；读取失败时返回-1</li><li><code>void close()</code><h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a><em>FileInputStream</em></h4></li></ol></li><li>构造方法传参<code>String name</code>或者<code>File file</code><h3 id="Reader类"><a href="#Reader类" class="headerlink" title="Reader类"></a>Reader类</h3></li><li>所有字符输入流的父类<h4 id="InputStreamReader-–-gt-FileReader"><a href="#InputStreamReader-–-gt-FileReader" class="headerlink" title="InputStreamReader –&gt; FileReader"></a><em>InputStreamReader –&gt; FileReader</em></h4></li><li>构造方法传参<h3 id="Writer类"><a href="#Writer类" class="headerlink" title="Writer类"></a>Writer类</h3><h4 id="OutputStreamWriter-–-gt-FileWriter"><a href="#OutputStreamWriter-–-gt-FileWriter" class="headerlink" title="OutputStreamWriter –&gt; FileWriter"></a><em>OutputStreamWriter –&gt; FileWriter</em></h4><h1 id="👉泛型"><a href="#👉泛型" class="headerlink" title="👉泛型"></a>👉泛型</h1></li><li>泛型是一种未知的数据类型，可以看作是一种变量，用来接收数据类型<ul><li>E - Element (在集合中使用，因为集合中存放的是元素)</li><li>T - Type（Java 类）</li><li>K - Key（键）</li><li>V - Value（值）</li><li>N - Number（数值类型）</li><li>?  - 表示不确定的java类型</li></ul></li><li>这些字母只是一种约定，并没有实际的指示意义</li><li><code>E</code>表示的就是未知的数据类型，在创建对象的时候，就可以确定这个泛型的类型了</li><li>在编译为Class文件时，会将泛型的信息全部擦除，所以其只在编译前起作用<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;      <span class="hljs-keyword">private</span> E[] list;   <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">method</span><span class="hljs-params">(E element)</span></span>&#123;          <span class="hljs-keyword">return</span> element;    &#125;  &#125;</code></pre><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;M&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(M element)</span></span>&#123;&#125;</code></pre><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span>&lt;<span class="hljs-title">I</span>&gt; </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(I value)</span></span>;  &#125;    <span class="hljs-comment">//第一种泛型接口的实现  </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterfaceImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyInterface</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(String value)</span> </span>&#123;&#125;  &#125;  <span class="hljs-comment">//第二种泛型接口的实现（根据接口所使用的泛型来确定实现类使用的泛型）  </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterfaceImpl2</span>&lt;<span class="hljs-title">I</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">MyInterface</span>&lt;<span class="hljs-title">I</span>&gt;</span>&#123;      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(I value)</span> </span>&#123;&#125;  &#125;</code></pre><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3></li><li><?> : 代表任意的数据类型</li><li>不能创建对象使用，只能作为方法的参数使用<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printArrayList</span><span class="hljs-params">(ArrayList&lt;?&gt; list)</span></span>&#123;      Iterator&lt;?&gt; it = list.iterator();  &#125;</code></pre><h3 id="泛型通配符的高级用法"><a href="#泛型通配符的高级用法" class="headerlink" title="泛型通配符的高级用法"></a>泛型通配符的高级用法</h3></li><li>泛型的上限限定 <code>&lt;? extends E&gt;</code> –&gt; 使用的泛型只能是E的子类/本身</li><li>泛型的下限限定 <code>&lt;? super E&gt;</code> –&gt; 使用的泛型类型只能是E的父类/本身<h1 id="👉集合框架"><a href="#👉集合框架" class="headerlink" title="👉集合框架"></a>👉集合框架</h1><img src="https://img-blog.csdnimg.cn/20190513101748368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70" alt="输入图片描述"><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2></li><li>所有单列集合的最顶层接口，定义了所有单列集合共性的方法</li><li>共性方法：<ul><li><code>public boolean add(E e)</code> ：添加对象到当前集合中</li><li><code>public void clear()</code> ：清空集合中的所有元素</li><li><code>public boolean remove(E e)</code> ：给定对象在集合中删除</li><li><code>public boolean contains(E e)</code> ：判断集合中是否有给定的对象</li><li><code>public boolean isEmpty()</code> ：判断是否为空</li><li><code>public int size()</code> ：返回集合中元素的个数</li><li><code>public Object[] toArray()</code> ：将集合中的元素存储到数组当中<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3></li></ul></li><li>有序集合</li><li>可存储重复元素</li><li>有索引，可使用普通for循环遍历；也包含一些带索引的方法</li><li>带索引的方法（特有）<ul><li><code>public void add(int index, E element)</code></li><li><code>public E remove(int index)</code> ：带删除的获取</li><li><code>public E get(int index)</code> ：获取元素，索引值和数组一样从0开始；也是一种遍历方式</li><li><code>public E set(int index, E element)</code> ：替换集合中指定位置的元素，返回值是更新前的元素<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4></li></ul></li><li>相对于基本数组的类型，其长度不受限制</li><li>泛型指定的类型必须是引用类型，不能是基本类型</li><li>如果需要存储基本类型，就需要包装类来代替这些基本类型。包装类其实有自动装箱、自动拆箱的功能，所以实际操作时，可以就当作基本类型使用</li><li>在打印ArrayList对象时，并不是打印地址值，而是list的内容。当其为空时的打印结果是<code>[]</code> （本质是ArrayList的toString方法特殊处理过）</li><li>是List的一个实现类，所以具有Collection和List接口中的所有方法</li><li>底层实现使用的是数组，每次在插入新元素时都会创建新的区域然后把原数据复制过去，所以增删的效率非常低<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4></li><li>底层是用链表实现的</li><li>相对于ArrayList查询慢、增删块</li><li>LinkedList包含了很多操作首尾的方法，所以不能使用多态</li><li>它也是List的一个实现类，所以具有Collection和List接口中的所有方法；但是具有更多的特殊方法：<ul><li><code>public void addFirst(E e)</code></li><li><code>public void addLast(E e)</code></li><li><code>public void push(E e)</code> ：插入到头部，和addFirst一样的</li><li><code>public E getFirst()</code></li><li><code>public E getLast()</code></li><li><code>public E removeFirst()</code></li><li><code>public E removeLast()</code></li><li><code>public E pop()</code> ：从头部弹出，和removeFirst一样的<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4></li></ul></li><li>以前的版本所使用的单列集合，它也是使用数组实现的底层</li><li>操作是用单线程的方法实现的，效率较低，现在已经很少使用了<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3></li><li>不允许重复元素</li><li>没有索引，所以不能普通for循环遍历；要借助Iterator来进行遍历<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4></li><li>无序的集合，不可预知遍历顺序</li><li>底层实现是哈希表的结构，所以查询速度非常快</li><li>哈希表的实现：<ul><li>jdk1.8之前 –&gt; 数组+链表</li><li>jdk1.8之后 –&gt; 数组+链表/红黑树（链表节点超过8个就转换为红黑树）</li></ul></li><li>HashSet存储自定义元素类型时，必须重写<code>hashCode()</code> 和 <code>equals()</code> 两个方法<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4></li><li>是HashSet的子类</li><li>相对于HashSet，存储的元素是有序的，可以预知遍历顺序</li><li>底层的实现是哈希表+链表，这个多出来的链表用于记录存储顺序，保证元素有序的<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a><em>Iterator迭代器</em></h2></li><li>通用的取出集合中元素的方式</li><li>迭代器为“不能普通for循环遍历”的集合提供了遍历的方法<h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4></li><li>使用Collection中的<code>iterator()</code>方法获取迭代器的实现类对象，用Iterator的接口接收（多态）</li><li>Iterator<E>接口的泛型要和集合的相同</li><li>使用提供的<code>hasNext()</code> 和 <code>next()</code>两个方法来遍历集合<h4 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h4></li><li>增强for的底层是由Iterator来实现的，是其简化版</li><li>只要实现了Iterable接口的对象，就可以成为foreach的目标<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a><em>Collections工具类</em></h2></li><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code> ：像向集合中添加一系列元素</li><li><code>public static void shuffle(List&lt;?&gt; list)</code> ：打乱集合的排序顺序</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code> ：将集合中的元素按照默认的方式进行排序</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> ：按照Comparator实现接口的排序方式进行排序<h3 id="针对自定义的类对象进行排序"><a href="#针对自定义的类对象进行排序" class="headerlink" title="针对自定义的类对象进行排序"></a>针对自定义的类对象进行排序</h3></li></ul><ol><li>实现Comparable接口中的CompareTo方法<ul><li>其实像<code>Integer、String...</code>都是实现了这个接口的，所以我们自定义的类是需要自己定义比较规则的</li><li>排序规则：<ul><li>this - object 升序</li><li>object - this 降序</li></ul></li></ul></li><li>单独实现Comparator接口，然后将这个比较器作为参数传递到<code>Collection.sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>函数中<ul><li>对于数值可以直接返回相减的值（返回值是int）</li><li>对于字符串可以调用字符串本身实现了的<code>compareTo</code>方法来获取字符串的比较结果</li><li>排序规则<ul><li>o1 - o2 ：升序</li><li>o2 - o1 ：降序<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2></li></ul></li></ul></li></ol><ul><li>Map具有键值对的概念，是双列集合（Collection是单列集合）</li><li>一个元素包含两个值 (key, value)；键和值是一一对应的，但是数据类型不相互制约</li><li>key值不允许重复，而value的值可以重复</li><li>Map&lt;K, V&gt;中常用的方法<ul><li><code>public V put(K key, V value)</code> ：把指定的 键-值 对添加到Map中（已存在的key将会替换掉其value值）<ul><li>存储时，若key不重复，返回null</li><li>存储时，若key重复了，返回被替换的value值</li></ul></li><li><code>public V remove(Object key)</code> ：删除指定key所对应的键值对<ul><li>key存在返回删除的value值</li><li>key不存在返回null</li><li>这里有一个注意：当value是基本类型时，如果直接返回成int类型会出现将null赋值给int的异常。所以建议使用包装类integer来接收数据</li></ul></li><li><code>public V get(Object key)</code></li><li><code>boolean containsKey(Object key)</code> ：判断是否包含某个键</li></ul><ol><li>遍历方法一：<code>Set&lt;K&gt; keySet()</code> ：把Map集合中的所有key取出来，存储在一个Set集合中，使用Set的遍历结合<code>get(Object key)</code>来遍历Map集合</li><li>遍历方法二：<code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code><ul><li>在Map中，键值对的底层存储是放在了一个Entry的映射关系中，可以使用这个方法将这些Entry的映射关系全部放到一个Set的集合中，来实现遍历</li><li>然后使用Set的迭代器取出所有的Entry对象</li><li>再调用Entry的<code>getKey()</code> 和 <code>getValue()</code>方法来获得Entry对象中的键-值</li></ul></li></ol></li><li>Map存储自定义类型的键值，和Set集合一样必须重写自定义对象的<code>hashCode()</code> 和 <code>equals()</code> 两个方法<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4></li><li>底层是哈希表实现</li><li>是一个无序集合，存取的顺序不一致</li><li>多线程实现的集合，不安全的集合，但是速度快<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4></li><li>继承自HashMap</li><li>底层是哈希表+链表（保证迭代顺序）</li><li>有序集合，存取顺序一致<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4></li><li>早期版本的双列集合，单线程实现的方法较为安全，但是速度较慢</li><li>HashMap可以存储null值，但是Hashtable不可以存储null值</li><li>Hashtable和Vector一样都已经被更先进的集合（HashMap、ArrayList）所代替</li><li>但是Hashtable的子类Properties依然在使用，它是唯一与IO流相结合的集合<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4></li></ul><h1 id="👉并发"><a href="#👉并发" class="headerlink" title="👉并发"></a>👉并发</h1><h2 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h2><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3></li><li>首先创建一个类，并要继承Thread类</li><li>重写run()方法之后，new一个对象之后调用start()方法来开启这个线程</li><li>main线程 –&gt; 主线程<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3></li><li>首先实现Runnable接口，并重写run()方法</li><li>然后new一个实现了Runnable接口的对象的实例<code>thread1</code></li><li>创建一个Thread对象的实例，将<code>thread1</code>作为参数传入其构造方法</li><li>调用start方法来启动线程</li><li>继承Thread类和实现Runnable接口本质上是一样的<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3></li><li>首先实现Callable接口，并重写Call()方法</li><li>相对于Runnable接口，可以自定义返回值、可以抛出异常</li><li>这里以线程返回为Boolean为例<pre><code class="hljs java">Hello t1 = <span class="hljs-keyword">new</span> Hello();  <span class="hljs-comment">//创建执行服务  </span>ExecutorService srv = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);  <span class="hljs-comment">//提交执行  </span>Future&lt;Boolean&gt; r1 = srv.submit(t1);  <span class="hljs-comment">//获取结果  </span><span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">boolean</span> rs1 = r1.get();  &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;      e.printStackTrace();  &#125;<span class="hljs-comment">//关闭服务  </span>srv.shutdown();</code></pre><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2></li><li>真实对象和代理对象都要实现同一个接口</li><li>代理角色要<strong>代理</strong>真实角色，将真实对象通过构造器传递给代理对象</li><li>优点：<ul><li>代理对象可以做很多真实对象无法做的事</li><li>真实对象专注于做自己的事</li></ul></li><li>其实实现Runnable接口的多线程编程就是这样的静态代理方式<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2></li><li>函数式接口：任何只包含唯一一个抽象方法的接口</li><li>对于函数式接口可以通过Lambda表达式来创建该接口的对象</li><li>本质上是简化代码量，使其更加简洁<pre><code class="hljs java">Runnable thread1 = <span class="hljs-keyword">null</span>;  thread1 = ()-&gt;&#123;      System.out.println(<span class="hljs-string">&quot;Thread1&quot;</span>);  &#125;;</code></pre></li><li>接口存在参数时，参数的类型是可以省略的。写成：<code>(a,b)-&gt;&#123;System.out.println(&quot;Thread&quot;);&#125;</code><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2></li><li>获取当前线程的信息<ul><li><code>Thread.currentThread().getName()</code></li><li><code>Thread.currentThread().getPriority()</code></li><li>……<h3 id="优先级priority"><a href="#优先级priority" class="headerlink" title="优先级priority"></a>优先级<code>priority</code></h3></li></ul></li><li>优先级数：1~10，数值越大优先级越高</li><li><code>thread.getPriority()</code> &amp; <code>thread.setPriority()</code></li><li>不显式设置优先级时，默认为5</li><li>优先级一定要在线程开始运行之前设置，否则没有意义<h3 id="线程停止stop"><a href="#线程停止stop" class="headerlink" title="线程停止stop"></a>线程停止<code>stop</code></h3></li><li>不推荐使用Thread类中提供的<code>stop()</code>、<code>destroy()</code>方法，这些方法已经弃用了</li><li>重写一个<code>stop()</code>方法，通过改变类中的一个标志位，来使线程跳出死循环从而实现线程自己停止结束<h3 id="线程休眠sleep"><a href="#线程休眠sleep" class="headerlink" title="线程休眠sleep"></a>线程休眠<code>sleep</code></h3></li><li>毫秒级的延时<code>Thread.sleep(int millis)</code></li><li>阻塞当前的线程</li><li>存在异常<code>InterruptedException</code></li><li><code>sleep()</code>并不会释放锁<h3 id="线程礼让yield"><a href="#线程礼让yield" class="headerlink" title="线程礼让yield"></a>线程礼让<code>yield</code></h3></li><li><code>Thread.yield()</code></li><li>让线程回到就绪队列，让CPU重新调度任务</li><li>所以调用这个函数不一定会使其他线程执行<h3 id="线程合并join"><a href="#线程合并join" class="headerlink" title="线程合并join"></a>线程合并<code>join</code></h3></li><li><code>thread.join()</code></li><li>让当前的线程等待指明的这个thread线程结束后再执行<h3 id="守护线程-daemon"><a href="#守护线程-daemon" class="headerlink" title="守护线程(daemon)"></a>守护线程(<code>daemon</code>)</h3></li><li>线程分为用户线程 和 守护线程</li><li>JVM虚拟机保证用户线程执行完毕，但不保证守护线程</li><li>守护线程有：记录操作日志、监控内存、垃圾回收……</li><li>将线程设置为守护线程<code>thread.setDaemon(true)</code>，默认是false表示用户线程<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h4 id="两种用法：synchronized方法-amp-synchronized块"><a href="#两种用法：synchronized方法-amp-synchronized块" class="headerlink" title="两种用法：synchronized方法 &amp; synchronized块"></a>两种用法：<code>synchronized</code>方法 &amp; <code>synchronized</code>块</h4></li></ul><ol><li>将方法声明为<code>private synchronized void method()</code> –&gt; 影响性能<ul><li>每个==对象==都有一个内置🔒，在调运这个方法时需要先获得这个内置的🔒</li><li>对于static的方法也可以加<code>synchronized</code>，但是这会锁住整个类</li></ul></li><li>同步块：<code>synchronized (object)&#123;...&#125;</code></li></ol><ul><li>同步方法是锁住的<code>this</code>对象，有时并不会按照我们预期的那样来运行<h2 id="锁-Lock"><a href="#锁-Lock" class="headerlink" title="锁 (Lock)"></a>锁 (Lock)</h2></li><li>显式定义同步锁来实现同步，底层的实现和前者是一样的</li><li>相对于<code>synchronized</code>，它是可重入锁</li><li>模板：<pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;      threadLock.lock();   <span class="hljs-keyword">if</span>(ticket &gt; <span class="hljs-number">0</span>)&#123;          System.out.println(ticket--);    Thread.sleep(<span class="hljs-number">1000</span>);    &#125;<span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">break</span>;    &#125;  &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;      e.printStackTrace();  &#125;<span class="hljs-keyword">finally</span> &#123;      threadLock.unlock();  &#125;</code></pre><h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2></li><li>使用<code>this.wait() &amp; this.notify/notifyAll()</code>两个方法来进行</li><li>这些方法是属于Object类的方法，并且必须在<code>synchronized</code>的临界区使用</li><li><code>this.wait()</code>被调用时，会释放此时持有的🔒</li><li>特别注意：<code>notify/notifyAll</code>两者的区别<ul><li><code>notify</code>只会唤醒一个在等待池中的进程，并开始竞争CPU和🔒</li><li><code>notifyAll</code>会唤醒所有在等待池中的进程，唤醒的进程同时开始竞争CPU和🔒<h3 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h3><h3 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h3><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2></li></ul></li><li>使用线程池可以提高相应速度，避免频繁的创建销毁，便于线程的管理<br>前面出现过了：<pre><code class="hljs java">ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);  service.execute(thread);  service.shutdown();</code></pre><h1 id="👉网络"><a href="#👉网络" class="headerlink" title="👉网络"></a>👉网络</h1><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a><code>InetAddress</code>类</h3></li><li>这个类没有构造方法无法实例化，只能通过其静态方法获得对象<pre><code class="hljs java">InetAddress srv = InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>);  InetAddress sw = InetAddress.getByName(<span class="hljs-string">&quot;192.168.0.1&quot;</span>);  InetAddress cli = InetAddress.getLocalHost();</code></pre></li><li>然后可以使用特定方法输出主机名、主机地址</li><li>所以这个类一般不通过生成一个对象来使用，而是直接调用静态方法来获取信息<h3 id="InetSocketAddress类"><a href="#InetSocketAddress类" class="headerlink" title="InetSocketAddress类"></a><code>InetSocketAddress</code>类</h3></li><li>相对于<code>InetAddress</code>多了port端口参数</li><li>拥有构造函数，需要进行实例化<h2 id="TCP套接字"><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h2><h3 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a><code>ServerSocket</code>类</h3></li><li>针对服务器建立的套接字，需要写入监听的端口</li><li>调用其<code>accept()</code>方法，返回客户端连接的<code>Socket</code>套接字<h3 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a><code>Socket</code>类</h3></li><li>构造函数中写入要连接的服务器地址端口，获得一个连接的套接字</li><li>通过<code>getOutputStream()</code> 和 <code>getInputStream()</code>方法来获得输入输出流<h3 id="字节流接收"><a href="#字节流接收" class="headerlink" title="字节流接收"></a>字节流接收</h3></li><li>需要一个中间的管道<code>ByteArrayOutputStream</code>来进行转换<pre><code class="hljs java"><span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];  <span class="hljs-keyword">int</span> len;  ByteArrayOutputStream baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();  <span class="hljs-keyword">while</span> ((len=is.read(buffer))!=-<span class="hljs-number">1</span>)&#123;      baos.write(buffer,<span class="hljs-number">0</span>,len);  &#125;System.out.println(baos.toString());</code></pre><h2 id="UDP套接字"><a href="#UDP套接字" class="headerlink" title="UDP套接字"></a>UDP套接字</h2><h3 id="DatagramSocket类"><a href="#DatagramSocket类" class="headerlink" title="DatagramSocket类"></a><code>DatagramSocket</code>类</h3></li><li>构造方法，传入port端口来指定要监听的端口</li><li>使用<code>send()</code>方法来发送用<code>DatagramPacket</code>构建的数据报文</li><li>使用<code>receive()</code>方法来接收用<code>DatagramPacket</code>构建的数据报空间<h3 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a><code>DatagramPacket</code>类</h3></li><li>用来建立数据报，包含字节流数据、要发送的地址端口</li><li>也可以用来创建接收数据报文的空间，需要注意使用的存储空间是Byte[]<h2 id="URL资源"><a href="#URL资源" class="headerlink" title="URL资源"></a>URL资源</h2></li><li>使用<code>HttpURLConnection</code>类进行资源的连接<pre><code class="hljs java">URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;https://www.****.com/photo.jpg&quot;</span>);HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();  InputStream is = urlConnection.getInputStream();  FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;photo.jpg&quot;</span>);    <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];  <span class="hljs-keyword">int</span> len;  <span class="hljs-keyword">while</span> ((len=is.read(buffer))!=-<span class="hljs-number">1</span>) &#123;      fos.write(buffer,<span class="hljs-number">0</span>,len);  &#125;</code></pre><h1 id="👉注解"><a href="#👉注解" class="headerlink" title="👉注解"></a>👉注解</h1></li><li>注解(Annotation) 和 注释有一定的相似性</li><li>注解不是必须的，但是对程序有一定的作用<h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2></li><li><code>@Override</code> ：重写的方法</li><li><code>@Deprecated</code> ：被遗弃，不在推荐使用的方法</li><li><code>@SuppressWarnings(&quot;all&quot;)</code> ：抑制编译时的警告信息，除了<code>&quot;all&quot;</code>之外还可以使用其他的参数<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2></li><li>元注解(meta-annotation)作用是注解其他的注解，为其他注解类型提供说明</li><li>四个标准的元注解<ol><li><code>@Target</code> ：描述注解使用的范围，在<code>ElementType</code>这个枚举类型中去找定义</li><li><code>@Retention</code> ：描述注解的生命周期。(SOURCE &lt; CLASS &lt; <strong>RUNTIME</strong>) 一般直接写RUNTIME</li><li><code>@Documented</code> ：表示是否将我们的注解生成在JAVAdoc中</li><li><code>@Inherited</code> ：表示子类可以继承父类中的注解</li></ol></li></ul><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><pre><code class="hljs java"><span class="hljs-meta">@Target(value = &#123;ElementType.METHOD&#125;)</span>  <span class="hljs-meta">@Retention(value = RetentionPolicy.RUNTIME)</span>  <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;      <span class="hljs-comment">//注解的参数：参数类型 + 参数名 ();  </span>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;  <span class="hljs-comment">//default表示调运注解不对其赋值时的默认值</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span></span>;      String[] school();  &#125;<span class="hljs-comment">//使用注解</span><span class="hljs-meta">@MyAnnotation(name = &quot;LZH&quot;, age = 19, school = &quot;电子科大&quot;)</span></code></pre><ul><li>当注解只有一个参数时，建议使用<code>valuse</code>。这样在使用注解的时候可以不用写<code>valuse =</code>，直接写要赋的值<h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2></li></ul><ol><li>编译检查：<code>@SuppressWarnings</code>, <code>@Deprecated</code>和 <code>@Override</code>都用编译检查的功能</li><li>在反射中使用注解：这是注解最为重要的功能，在通过反射来调用对象方法时，可以反射出注解中的内容，从而影响程序的运行；这在各种框架中被广泛使用</li><li>根据注解生成帮助文档，<code>@Documented</code>标签的功能<h1 id="👋反射"><a href="#👋反射" class="headerlink" title="👋反射"></a>👋反射</h1></li></ol><ul><li>静态语言 VS 动态语言<ul><li>静态语言运行时结构不可变，动态语言运行时的结构是可以改变的</li><li>反射机制将本来是静态语言的Java变成了==准动态语言==</li></ul></li><li>反射允许程序在执行期间借助Reflection API取得任何类的内部信息，并能够直接操作对象的内部属性及方法</li></ul><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><ul><li>一共有三种方式来获取Class对象：<ol><li>通过实例对象的<code>getClass()</code>方法（继承自Object类的方法）获取</li><li>通过类的属性值直接获取<code>Object.Class</code>，但是这种方法需要导入相关的包</li><li>使用Class类的静态方法，通过目标类真实路径的字符串来获取<code>Class.forName(&quot;fanshe.Student&quot;)</code></li></ol></li></ul><h3 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h3><ul><li>获取构造方法之前，需要先拿到类的Class对象，然后调用Class的实例方法来查找构造器</li><li>查找所有的构造器<code>getDeclaredConstructors()</code>或<code>getConstructors()</code>（前者是查找所有构造器，后者是查找所有**<em>公有**</em>的构造器）</li><li>查找指定的构造器（即给定传入参数的类型）：<pre><code class="hljs java">Class[] p2 = &#123;<span class="hljs-keyword">int</span>.class, String.class&#125;;Constructor constructor = cstd.getDeclaredConstructor(p2);constructor.setAccessible(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//更改构造器的访问权限，使得private的构造器也能调用</span>Object obj = constructor.newInstance(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;Jobs&quot;</span>); <span class="hljs-comment">//返回的直接类型都是Object的</span>Student std2 = (Student) constructor.newInstance(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;Jobs&quot;</span>); <span class="hljs-comment">//可以强制类型转化</span></code></pre></li><li>带有<code>Declared</code>的 就是查找所有的，没带的就是只查找公有的</li></ul><h3 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h3><ul><li>获取所有的成员变量（分有<code>Declared</code>和没有两种）：<pre><code class="hljs java">Field[] fieldArray = cstd.getDeclaredFields();Field[] fieldArray = cstd.getFields();</code></pre></li><li>通过变量名，获取具体的某个成员变量（分有<code>Declared</code>和没有两种）：<pre><code class="hljs java">Field f = cstd.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);  f.setAccessible(<span class="hljs-keyword">true</span>);  <span class="hljs-comment">//更改访问权限，解除私有限定</span>f.set(std, <span class="hljs-number">100</span>); <span class="hljs-comment">//设置std这个实例对象中的f所指向的局部变量的值</span></code></pre></li></ul><h3 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h3><ul><li>获取所有成员方法<pre><code class="hljs java">Method[] methodArray = cstd.getDeclaredMethods();</code></pre></li><li>获取指定的成员方法并调用：<pre><code class="hljs java">Method m = cstd.getDeclaredMethod(<span class="hljs-string">&quot;testMethod&quot;</span>, <span class="hljs-keyword">int</span>.class, String.class);  m.setAccessible(<span class="hljs-keyword">true</span>);  Object obj = m.invoke(std, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;Jobs&quot;</span>); <span class="hljs-comment">//返回值的类型都是Object的，可以做强制类型转换</span></code></pre><h3 id="反射注解"><a href="#反射注解" class="headerlink" title="反射注解"></a>反射注解</h3></li><li>获取到注解的字段中的内容，根据注解的内容改变程序执行的逻辑<pre><code class="hljs java">Host host = <span class="hljs-keyword">new</span> Host();  <span class="hljs-keyword">if</span> (host.getClass().isAnnotationPresent(MyAnnotation.class)) &#123;  MyAnnotation annotation = host.getClass().getAnnotation(MyAnnotation.class);  String value = annotation.value();  System.out.println(value);  &#125;</code></pre></li></ul><h3 id="反射main方法"><a href="#反射main方法" class="headerlink" title="反射main方法"></a>反射main方法</h3><pre><code class="hljs java">Method m = cstd.getMethod(<span class="hljs-string">&quot;main&quot;</span>, String[].class);  m.invoke(<span class="hljs-keyword">null</span>, (Object) <span class="hljs-keyword">null</span>);</code></pre><h3 id="通过反射运行配置文件"><a href="#通过反射运行配置文件" class="headerlink" title="通过反射运行配置文件"></a>通过反射运行配置文件</h3><h3 id="通过反射越过泛型检查"><a href="#通过反射越过泛型检查" class="headerlink" title="通过反射越过泛型检查"></a>通过反射越过泛型检查</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>About me</title>
    <link href="/2020/09/28/hello-world/"/>
    <url>/2020/09/28/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h1><ul><li>来自沙河职业技术学院的一名学生</li><li>身在孤儿软件工程学院</li><li>目前从事<code>Java</code>的后端开发</li><li>……</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
