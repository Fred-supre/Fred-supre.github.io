

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>JavaSE - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-10-28 19:28" pubdate>
        2020年10月28日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      95
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">JavaSE</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><p>最后更新：2020.7.10<br><img src="D:/Work/GitHub/blog/myfile/JavaSE_md_files/TIM截图20200624004248_20200624004330.png" srcset="/img/loading.gif" alt="输入图片描述"></p>
<h2 id="Java-三大版本"><a href="#Java-三大版本" class="headerlink" title="Java 三大版本"></a>Java 三大版本</h2><ul>
<li>JavaSE    桌面端</li>
<li><del>JavaME 移动端</del></li>
<li>JavaEE Web端/服务器</li>
</ul>
<h2 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK / JRE / JVM"></a>JDK / JRE / JVM</h2><p><img src="http://codingfox.com/wp-content/uploads/2014/11/jdk-doc.png" srcset="/img/loading.gif" alt="输入图片描述"></p>
<h1 id="👉Java基础"><a href="#👉Java基础" class="headerlink" title="👉Java基础"></a>👉Java基础</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>基本类型<ul>
<li>数值<ul>
<li>整数：byte、short、int、long</li>
<li>浮点：float、double</li>
</ul>
</li>
<li>字符：char        (Java使用的Unicode，占用2个字节)</li>
<li>布尔：boolean    (占一位，取值只有<code>true</code>&amp;<code>false</code>)</li>
</ul>
</li>
<li>引用类型</li>
</ul>
<blockquote>
<p>类型拓展</p>
</blockquote>
<ul>
<li>不使用浮点数进行比较，转而使用一个BigDecimal的类来表示浮点数</li>
<li>基本类型都有对应的方法类，如：Integer、Short、Long……（静态，属于工具类）</li>
<li>数字可以使用下划线进行分割 <code>int a = 10_000_000;</code></li>
</ul>
<blockquote>
<p>类型转换</p>
</blockquote>
<ul>
<li>类型顺序：低 —————————-&gt; 高<br><code>byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</code></li>
<li>低 -&gt; 高：自动类型转换</li>
<li>高 -&gt; 低：强制类型转换</li>
<li><code>char</code>类型在进行赋值时都需要强制转换</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>局部变量<ul>
<li>必须有初始化值</li>
<li>存在且只在当前的方法和代码块中起作用</li>
</ul>
</li>
<li>实例变量<ul>
<li>存在于类，但是需要实例化的变量。属于每个实例</li>
<li>可以不用赋初始值，会自动设置为默认值<code>0 或者 null 或者 false</code></li>
</ul>
</li>
<li>类变量<ul>
<li>属于类的变量，有<code>static</code>修饰</li>
<li>不会受实例化对象的影响</li>
</ul>
</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li>存在于类当中，不能被修改</li>
<li><code>static final</code>修饰</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>这里只提一下<code>+</code>在字符串拼接中的用法</li>
<li>Java中的<code>+</code>在数值运算和字符串的拼接中都有意义</li>
<li>当其两侧都是数值时就是==加==，当两侧存在String时就是==拼接==</li>
</ul>
<pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">12</span>;  
<span class="hljs-keyword">int</span> b = <span class="hljs-number">30</span>;  
System.out.println(<span class="hljs-string">&quot;&quot;</span>+a+b);  
System.out.println(a+b+<span class="hljs-string">&quot;&quot;</span>);

<span class="hljs-comment">//输出结果</span>
<span class="hljs-number">1230</span>
<span class="hljs-number">42</span></code></pre>

<h1 id="👉Java流程控制"><a href="#👉Java流程控制" class="headerlink" title="👉Java流程控制"></a>👉Java流程控制</h1><ul>
<li>Scanner对象</li>
</ul>
<pre><code class="hljs java">Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);
in.hasNext();	<span class="hljs-comment">//return boolean</span>
in.next();		<span class="hljs-comment">//return 指明的类型（String、int、float……）</span>
in.hasNext~();
in.next~();</code></pre>

<ul>
<li>if选择语句</li>
<li>switch选择语句</li>
<li>while循环语句</li>
<li>for循环语句</li>
</ul>
<pre><code class="hljs java"><span class="hljs-comment">//增强型的for，主要用于数组、集合</span>
<span class="hljs-keyword">int</span>[] set = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">20</span>];  
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i:set)&#123;
&#125;</code></pre>

<ul>
<li>break、continue、goto <ul>
<li>Java语法中goto语句并没有任何用处，只是作为了保留字</li>
<li>只有一个标签的使用方式，和C语言中goto的用法是相同的</li>
</ul>
</li>
</ul>
<pre><code class="hljs java">label:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i:set)&#123;  
    <span class="hljs-keyword">continue</span> label;  
&#125;</code></pre>

<h1 id="👉Java方法"><a href="#👉Java方法" class="headerlink" title="👉Java方法"></a>👉Java方法</h1><ul>
<li>方法重载：相同函数名，不同参数</li>
<li>可变参数的方法<ul>
<li>指定参数后面加省略号(…)</li>
<li>一个方法只能有一个可变参数，并且要是方法的最后一个参数</li>
<li>本质是使用了数组</li>
</ul>
</li>
</ul>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span>... b)</span></span>&#123;  
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i:b)&#123;  
        System.out.println(i);  
  &#125;  
&#125;</code></pre>

<h1 id="👉Java数组"><a href="#👉Java数组" class="headerlink" title="👉Java数组"></a>👉Java数组</h1><ul>
<li>数组是引用类型</li>
<li>像数组这样的引用类型，其new出来的对象都是存储在堆区的</li>
<li>其它的基本类型和引用类型的“指针”都在栈区</li>
<li>有对应的方法类：Arrays（静态，属于工具类）</li>
</ul>
<h1 id="👉面向对象"><a href="#👉面向对象" class="headerlink" title="👉面向对象"></a>👉面向对象</h1><ul>
<li>三大特性：封装、继承、多态</li>
<li>方法的特性：<ul>
<li>静态方法 –&gt; static修饰，通过类来调用</li>
<li>非静态方法 –&gt; 没有static修饰，通过对象来调用</li>
</ul>
</li>
<li>this关键字使用：指明是本对象中的属性</li>
<li>构造器<ul>
<li>没有声明构造器时，默认存在一个无参的构造器</li>
<li>构造器是无参数（底层返回的示例对象地址），没有返回类型的函数</li>
<li>在new时本质就是调用的构造器，用于初始化对象的函数</li>
</ul>
</li>
<li>==封装==<ul>
<li>属性私有：使用<code>private</code>关键字修饰类的属性</li>
<li>不能直接通过对象来访问修改这些属性，而需要用一些向外部提供的方法(<code>get/set</code>)来访问</li>
<li>这样很好的提供了数据的底层封装，保证了数据的安全性</li>
</ul>
</li>
<li>==继承==<ul>
<li>通过关键字<code>extands</code>来继承父类的所有属性和方法</li>
<li>使用<code>private</code>修饰的属性是没有办法在子类中访问的<br><img src="D:/Work/GitHub/blog/myfile/JavaSE_md_files/image_20200626090339.png" srcset="/img/loading.gif"></li>
</ul>
</li>
<li><code>super-this</code>关键字<ul>
<li>对于子类的构造器，默认会调用父类的无参构造方法<code>super()</code></li>
<li>并且这个父类的方法，必须在子类构造方法的第一行</li>
<li><code>super()</code>和<code>this()</code>两个方法不能同时调用</li>
<li>通过这两个关键字可以指定访问父类和子类中的属性</li>
</ul>
</li>
<li>重写<ul>
<li>子类中的方法，可以重写父类中的方法</li>
<li>方法名和参数列表必须相同</li>
<li>修饰符：范围可以扩大但不能缩小</li>
<li>抛出异常：范围可以缩小但不能放大</li>
</ul>
</li>
<li>==多态==<ul>
<li>动态编译，是可扩展性更强</li>
<li>实现方式：将父类的引用指向子类实例对象（注意，不要倒过来将父类的引用指向子类实例对象）</li>
<li>父类的引用指向子类的实例时，由于方法的重写，将会调用子类的方法，这就实现了<strong>多态</strong></li>
<li>但是对于<code>static</code>的方法，只由引用的类型来决定，所以调用的方法来自于父类 </li>
</ul>
</li>
<li><code>instanceof</code>关键字：用于检查对象是否在继承链条当中</li>
<li>类型转换<ul>
<li>将子类型转换为父类型，像上转型、默认转换。</li>
<li>将父类型转换为子类型，向下转型、强制转换。但是会丢失一部分的方法</li>
</ul>
</li>
<li><code>static</code>关键字<ul>
<li>静态变量（类变量）</li>
<li>静态方法</li>
<li>代码块<ul>
<li>静态代码块：最先调用的代码块，并且只再第一次new时调用一次</li>
<li>匿名代码块：静态代码块调用之后，调用匿名代码块。每次new一个新的实例时都会执行这个代码块</li>
<li>以上两者执行之后再开始调用构造方法</li>
</ul>
</li>
<li>静态导入包：在<code>import</code>包时，使用<code>static</code>修饰之后，调用静态类方法时，不用指明类名，可以直接调用方法(函数)</li>
</ul>
</li>
<li>抽象类：使用<code>abstract</code>修饰的类<ul>
<li>抽象类中可以有普通的方法，抽象的方法需要使用<code>abstract</code>关键词修饰</li>
<li>而抽象方法，必须写到抽象类当中</li>
<li>抽象类的方法，必须要通过子类来实现；同时抽象类也必须要通过继承后，才能实例化</li>
</ul>
</li>
<li>接口：只有规范和约束<ul>
<li>接口需要有一个实现类；<code>implements</code>关键词来从重写接口中的方法</li>
<li>接口中的方法，默认有<code>public abstract</code>关键字</li>
<li>接口中变量，默认有<code>public static final</code>关键字。也就是说接口中的变量都是静态常量</li>
</ul>
</li>
<li>内部类：在外部类中声明的一个类，叫做内部类<ul>
<li>静态内部类</li>
<li>局部内部类：写在方法中的内部类</li>
<li>匿名内部类</li>
</ul>
</li>
</ul>
<h1 id="👉枚举类"><a href="#👉枚举类" class="headerlink" title="👉枚举类"></a>👉枚举类</h1><ul>
<li>枚举类不继承自<code>Object</code>，而是继承自<code>java.lang.Enum</code>类</li>
<li>枚举的一个重要特性是，不能通过反射获得，这与后面实现单例模式有很大的关系</li>
</ul>
<h1 id="👉异常"><a href="#👉异常" class="headerlink" title="👉异常"></a>👉异常</h1><ul>
<li>错误(Error)和异常(Exception)</li>
<li>有一个重要的子类是运行时异常，由编码造成的</li>
<li>其余是非运行时异常</li>
<li>捕获异常时一定要从小到大来进行捕获</li>
</ul>
<h3 id="主动抛出异常"><a href="#主动抛出异常" class="headerlink" title="主动抛出异常"></a>主动抛出异常</h3><ul>
<li>通过throw来进行主动抛出异常，一般在方法中使用。但是这里主动抛出了异常，就需要我们去捕获处理</li>
<li>如果在本方法中不能捕获处理这个异常，那么就需要使用<code>throws</code>将这个异常在方法上抛出，让外层调用时捕获处理这个异常</li>
</ul>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul>
<li>定义一个异常类，需要继承<code>Exception</code></li>
</ul>
<h1 id="👋常用类"><a href="#👋常用类" class="headerlink" title="👋常用类"></a>👋常用类</h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><ul>
<li>所有类的父类，结构层次中的根类</li>
</ul>
<h3 id="重要的方法"><a href="#重要的方法" class="headerlink" title="重要的方法"></a>重要的方法</h3><ul>
<li><code>toString()</code><ul>
<li>直接打印对象的名字就是调用的<code>toString()</code>的返回结果</li>
<li>这个方法默认是打印<code>hashCode()</code>，所以一般是需要重写<code>toString()</code>方法的</li>
</ul>
</li>
<li><code>equals()</code><ul>
<li>用来比较引用类型是否指向同一个对象，也就是比较的<code>hashCode()</code></li>
<li>但是我们一般是需要比较对象的属性是否相同的，所以也需要重写<code>equals()</code>方法</li>
<li>由于<code>equals()</code>方法的传入参数是Object类的对象，多态的特性使其不能访问子类的属性，所以这里需要强行向下转型</li>
</ul>
</li>
</ul>
<h3 id="Objects工具类"><a href="#Objects工具类" class="headerlink" title="Objects工具类"></a>Objects工具类</h3><ul>
<li><code>Objects.equals(Object a, Object b)</code> : 这个方法的底层依然会调用<code>a.equals(b)</code>，但是在a为<code>null</code>时，可以避免返回异常</li>
</ul>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="“-”连接符"><a href="#“-”连接符" class="headerlink" title="“+”连接符"></a>“+”连接符</h3><ul>
<li>本质上是通过<code>StringBuffer</code>或者<code>StringBuilder</code>类的<code>append()</code>方法来实现的</li>
<li>每次调用的<code>+</code>连接符都会去<code>new</code>一个新的<code>StringBuilder</code>对象来完成字符串的拼接，然后在通过<code>toString()</code>将其类型转换成<code>String</code>类型</li>
<li>所以当我们在进行循环里面的字符串拼接时，要手动创建<code>StringBuilder</code>来进行拼接，避免每一次循环都要<code>new</code>新的对象，还用转换成<code>String</code>类型</li>
</ul>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><ul>
<li>在Java的内存分配中，总共3种常量池，分别是<strong>Class常量池</strong>、<strong>运行时常量池</strong>、<strong>字符串常量池</strong></li>
<li>JVM针对字符串的实例化做了优化：每当创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中</li>
<li>这样的优化是针对于<code>String str = &quot;hello&quot;</code>这样的直接赋值方式</li>
<li>但是直接通过构造方法声明的话<code>String str= new String(&quot;hello&quot;)</code>是直接在堆内存中创建对象，就不会有优化的功能，相同的字符串创建的对象在堆内存中不是同一个对象</li>
<li><code>String</code>类提供了一个将声明在堆中的<code>String</code>对象转换为字符串常量池中的对象的方法：<code>String::intern</code></li>
</ul>
<h3 id="StringBuffer-amp-StringBuilder"><a href="#StringBuffer-amp-StringBuilder" class="headerlink" title="StringBuffer &amp; StringBuilder"></a>StringBuffer &amp; StringBuilder</h3><p><img src="D:/Work/GitHub/blog/myfile/JavaSE_md_files/image_20201027152600.png" srcset="/img/loading.gif"></p>
<h1 id="👋IO"><a href="#👋IO" class="headerlink" title="👋IO"></a>👋IO</h1><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><ul>
<li>这是一个与操作系统无关的类，在任何操作系统下都可以运行</li>
<li>使用这个类可以进行一些文件相关的操作：<ul>
<li>创建文件/文件夹</li>
<li>删除文件/文件夹</li>
<li>获取文件/文件夹</li>
<li>判断文件/文件夹是否存在</li>
<li>对文件夹进行遍历</li>
<li>获取文件大小</li>
</ul>
</li>
</ul>
<h3 id="File的静态成员变量"><a href="#File的静态成员变量" class="headerlink" title="File的静态成员变量"></a>File的静态成员变量</h3><ul>
<li>路径分隔符：<code>File.pathSeparator</code><ul>
<li>Windows：<code>;</code></li>
<li>Linux：<code>:</code></li>
</ul>
</li>
<li>名称分隔符：<code>File.separator</code><ul>
<li>Windows：<code>\</code></li>
<li>Linux：<code>/</code></li>
</ul>
</li>
</ul>
<h3 id="File的构造方法"><a href="#File的构造方法" class="headerlink" title="File的构造方法"></a>File的构造方法</h3><ol>
<li>以字符串的形式，直接传入文件/文件夹的路径</li>
<li>将路径分成<code>parent</code>和<code>child</code>两部分，都以字符串的形式表示</li>
<li>路径分成<code>parent</code>和<code>child</code>两部分，但是<code>parent</code>是File类型的</li>
</ol>
<h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><ul>
<li><code>public String getAbsolutePath()</code>：返回文件的绝对路径</li>
<li><code>public String getPath()</code>：获取文件的路径，具体和创建时的输入路径有关（可能绝对、可能相对）</li>
<li><code>public String getName()</code>：返回文件/文件夹的名字</li>
<li><code>public long length()</code>：返回文件的字节长度，对文件夹和找不到的文件都返回<code>0</code></li>
</ul>
<h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3><ul>
<li><code>public boolean exists()</code>：文件/文件夹是否存在？</li>
<li><code>public boolean isDirectory()</code>：是否是文件夹？</li>
<li><code>public boolean isFile()</code>：是否是文件？</li>
</ul>
<h3 id="创建删除方法"><a href="#创建删除方法" class="headerlink" title="创建删除方法"></a>创建删除方法</h3><ul>
<li><code>public boolean createNewFile()</code>：创建File对象所指明的文件。文件已经存在、文件的路径不存在都会导致创建失败，报出异常</li>
<li><code>public boolean mkdir()</code>：创建单级文件夹。文件夹已存在或者路径不存在时，创建失败返回<code>false</code></li>
<li><code>public boolean mkdirs()</code>：创建多级文件夹，一般都用这个</li>
<li><code>public boolean delete()</code>：删除文件或者文件夹。当文件/文件夹不存在时，返回<code>false</code>；当文件夹中有内容时，不会删除并返回<code>false</code></li>
</ul>
<h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><ul>
<li><code>public String[] list()</code>：返回目录下的文件/文件夹名集合</li>
<li><code>public File[] listFiles()</code>：返回目录下的文件/文件夹的File对象集合</li>
</ul>
<h3 id="文件过滤器"><a href="#文件过滤器" class="headerlink" title="文件过滤器"></a>文件过滤器</h3><ul>
<li><code>FileFilter</code>接口，实现<code>public boolean accept(File pathname)</code>方法</li>
<li><code>FilenameFilter</code>接口，实现<code>public boolean accept(File dir, String name)</code>方法</li>
<li>将两种接口的实现类对象作为参数传递给<code>list()</code>或<code>listFiles()</code>方法</li>
</ul>
<h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><table>
<thead>
<tr>
<th></th>
<th>输入流</th>
<th>输出流</th>
</tr>
</thead>
<tbody><tr>
<td>字节流</td>
<td><code>InputStream</code></td>
<td><code>OutputStream</code></td>
</tr>
<tr>
<td>字符流</td>
<td><code>Reader</code></td>
<td><code>Writer</code></td>
</tr>
</tbody></table>
<ul>
<li>顶层的四个流的父类</li>
<li>计算机中的所有文件都是以字节来存储的，所以传输过程中也是以字节来进行传输</li>
</ul>
<h3 id="OutputStream类"><a href="#OutputStream类" class="headerlink" title="OutputStream类"></a>OutputStream类</h3><ul>
<li>所有字节输出流的父类</li>
<li>通用方法：<ol>
<li>   <code>void close()</code></li>
<li>   <code>void flush()</code>：刷新此输出流并强制任何缓冲的输出字节被写出</li>
<li>   <code>void write(byte[] b)</code>：将 <code>b.length</code>字节从指定的字节数组写入此输出流</li>
<li>   <code>void write(byte[] b, int off, int len)</code>：从指定的字节数组写入 <code>len</code>个字节，从偏移 <code>off</code>开始</li>
<li>   <code>abstract void write(int b)</code>：将指定的字节写入此输出流</li>
</ol>
</li>
</ul>
<h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a><em>FileOutputStream</em></h4><ul>
<li>构造方法传参<code>String name</code>或者<code>File file</code></li>
<li>构造方法传入参数<code>boolean append</code>为<code>true</code>，代表文件内容追加；默认为<code>false</code>代表覆盖写入</li>
<li>调用<code>write()</code>方法写入数据时，需要将字符串转换为Byte流，使用方法<code>string.getBytes()</code>进行转换</li>
</ul>
<h3 id="InputStream类"><a href="#InputStream类" class="headerlink" title="InputStream类"></a>InputStream类</h3><ul>
<li>所有字节输入流的父类</li>
<li>通用方法<ol>
<li><code>int read()</code>：读取一个字节并直接返回，结尾返回-1</li>
<li><code>int read(byte[] b)</code>：读取一定数量的字节数，并存储在缓冲区数组中，返回值int表示读取的字节数；读取失败时返回-1</li>
<li><code>void close()</code></li>
</ol>
</li>
</ul>
<h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a><em>FileInputStream</em></h4><ul>
<li>构造方法传参<code>String name</code>或者<code>File file</code></li>
</ul>
<h3 id="Reader类"><a href="#Reader类" class="headerlink" title="Reader类"></a>Reader类</h3><ul>
<li>所有字符输入流的父类</li>
</ul>
<h4 id="InputStreamReader-–-gt-FileReader"><a href="#InputStreamReader-–-gt-FileReader" class="headerlink" title="InputStreamReader –&gt; FileReader"></a><em>InputStreamReader –&gt; FileReader</em></h4><ul>
<li>构造方法传参</li>
</ul>
<h3 id="Writer类"><a href="#Writer类" class="headerlink" title="Writer类"></a>Writer类</h3><h4 id="OutputStreamWriter-–-gt-FileWriter"><a href="#OutputStreamWriter-–-gt-FileWriter" class="headerlink" title="OutputStreamWriter –&gt; FileWriter"></a><em>OutputStreamWriter –&gt; FileWriter</em></h4><h1 id="👉泛型"><a href="#👉泛型" class="headerlink" title="👉泛型"></a>👉泛型</h1><ul>
<li>泛型是一种未知的数据类型，可以看作是一种变量，用来接收数据类型<ul>
<li>E - Element (在集合中使用，因为集合中存放的是元素)</li>
<li>T - Type（Java 类）</li>
<li>K - Key（键）</li>
<li>V - Value（值）</li>
<li>N - Number（数值类型）</li>
<li>?  - 表示不确定的java类型</li>
</ul>
</li>
<li>这些字母只是一种约定，并没有实际的指示意义</li>
<li><code>E</code>表示的就是未知的数据类型，在创建对象的时候，就可以确定这个泛型的类型了</li>
<li>在编译为Class文件时，会将泛型的信息全部擦除，所以其只在编译前起作用</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;  
    <span class="hljs-keyword">private</span> E[] list;  
 <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">method</span><span class="hljs-params">(E element)</span></span>&#123;  
        <span class="hljs-keyword">return</span> element;  
  &#125;  
&#125;</code></pre>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;M&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(M element)</span></span>&#123;&#125;</code></pre>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span>&lt;<span class="hljs-title">I</span>&gt; </span>&#123;  
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(I value)</span></span>;  
&#125;  
  
<span class="hljs-comment">//第一种泛型接口的实现  </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterfaceImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyInterface</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;  
    <span class="hljs-meta">@Override</span>  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(String value)</span> </span>&#123;&#125;  
&#125;  
<span class="hljs-comment">//第二种泛型接口的实现（根据接口所使用的泛型来确定实现类使用的泛型）  </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterfaceImpl2</span>&lt;<span class="hljs-title">I</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">MyInterface</span>&lt;<span class="hljs-title">I</span>&gt;</span>&#123;  
    <span class="hljs-meta">@Override</span>  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(I value)</span> </span>&#123;&#125;  
&#125;</code></pre>

<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><ul>
<li><?> : 代表任意的数据类型</li>
<li>不能创建对象使用，只能作为方法的参数使用</li>
</ul>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printArrayList</span><span class="hljs-params">(ArrayList&lt;?&gt; list)</span></span>&#123;  
    Iterator&lt;?&gt; it = list.iterator();  
&#125;</code></pre>

<h3 id="泛型通配符的高级用法"><a href="#泛型通配符的高级用法" class="headerlink" title="泛型通配符的高级用法"></a>泛型通配符的高级用法</h3><ul>
<li>泛型的上限限定 <code>&lt;? extends E&gt;</code> –&gt; 使用的泛型只能是E的子类/本身</li>
<li>泛型的下限限定 <code>&lt;? super E&gt;</code> –&gt; 使用的泛型类型只能是E的父类/本身</li>
</ul>
<h1 id="👉集合框架"><a href="#👉集合框架" class="headerlink" title="👉集合框架"></a>👉集合框架</h1><p><img src="https://img-blog.csdnimg.cn/20190513101748368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hY1d4,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="输入图片描述"></p>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><ul>
<li>所有单列集合的最顶层接口，定义了所有单列集合共性的方法</li>
<li>共性方法：<ul>
<li><code>public boolean add(E e)</code> ：添加对象到当前集合中</li>
<li><code>public void clear()</code> ：清空集合中的所有元素</li>
<li><code>public boolean remove(E e)</code> ：给定对象在集合中删除</li>
<li><code>public boolean contains(E e)</code> ：判断集合中是否有给定的对象</li>
<li><code>public boolean isEmpty()</code> ：判断是否为空</li>
<li><code>public int size()</code> ：返回集合中元素的个数</li>
<li><code>public Object[] toArray()</code> ：将集合中的元素存储到数组当中</li>
</ul>
</li>
</ul>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><ul>
<li>有序集合</li>
<li>可存储重复元素</li>
<li>有索引，可使用普通for循环遍历；也包含一些带索引的方法</li>
<li>带索引的方法（特有）<ul>
<li><code>public void add(int index, E element)</code></li>
<li><code>public E remove(int index)</code> ：带删除的获取</li>
<li><code>public E get(int index)</code> ：获取元素，索引值和数组一样从0开始；也是一种遍历方式</li>
<li><code>public E set(int index, E element)</code> ：替换集合中指定位置的元素，返回值是更新前的元素</li>
</ul>
</li>
</ul>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul>
<li>相对于基本数组的类型，其长度不受限制</li>
<li>泛型指定的类型必须是引用类型，不能是基本类型</li>
<li>如果需要存储基本类型，就需要包装类来代替这些基本类型。包装类其实有自动装箱、自动拆箱的功能，所以实际操作时，可以就当作基本类型使用</li>
<li>在打印ArrayList对象时，并不是打印地址值，而是list的内容。当其为空时的打印结果是<code>[]</code> （本质是ArrayList的toString方法特殊处理过）</li>
<li>是List的一个实现类，所以具有Collection和List接口中的所有方法</li>
<li>底层实现使用的是数组，每次在插入新元素时都会创建新的区域然后把原数据复制过去，所以增删的效率非常低</li>
</ul>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul>
<li>底层是用链表实现的</li>
<li>相对于ArrayList查询慢、增删块</li>
<li>LinkedList包含了很多操作首尾的方法，所以不能使用多态</li>
<li>它也是List的一个实现类，所以具有Collection和List接口中的所有方法；但是具有更多的特殊方法：<ul>
<li><code>public void addFirst(E e)</code></li>
<li><code>public void addLast(E e)</code></li>
<li><code>public void push(E e)</code> ：插入到头部，和addFirst一样的</li>
<li><code>public E getFirst()</code></li>
<li><code>public E getLast()</code></li>
<li><code>public E removeFirst()</code></li>
<li><code>public E removeLast()</code></li>
<li><code>public E pop()</code> ：从头部弹出，和removeFirst一样的</li>
</ul>
</li>
</ul>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul>
<li>以前的版本所使用的单列集合，它也是使用数组实现的底层</li>
<li>操作是用单线程的方法实现的，效率较低，现在已经很少使用了</li>
</ul>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><ul>
<li>不允许重复元素</li>
<li>没有索引，所以不能普通for循环遍历；要借助Iterator来进行遍历</li>
</ul>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul>
<li>无序的集合，不可预知遍历顺序</li>
<li>底层实现是哈希表的结构，所以查询速度非常快</li>
<li>哈希表的实现：<ul>
<li>jdk1.8之前 –&gt; 数组+链表</li>
<li>jdk1.8之后 –&gt; 数组+链表/红黑树（链表节点超过8个就转换为红黑树）</li>
</ul>
</li>
<li>HashSet存储自定义元素类型时，必须重写<code>hashCode()</code> 和 <code>equals()</code> 两个方法</li>
</ul>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul>
<li>是HashSet的子类</li>
<li>相对于HashSet，存储的元素是有序的，可以预知遍历顺序</li>
<li>底层的实现是哈希表+链表，这个多出来的链表用于记录存储顺序，保证元素有序的</li>
</ul>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><h2 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="==Iterator==迭代器"></a><em>==Iterator==迭代器</em></h2><ul>
<li>通用的取出集合中元素的方式</li>
<li>迭代器为“不能普通for循环遍历”的集合提供了遍历的方法</li>
</ul>
<h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><ul>
<li>使用Collection中的<code>iterator()</code>方法获取迭代器的实现类对象，用Iterator的接口接收（多态）</li>
<li>Iterator<E>接口的泛型要和集合的相同</li>
<li>使用提供的<code>hasNext()</code> 和 <code>next()</code>两个方法来遍历集合</li>
</ul>
<h4 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h4><ul>
<li>增强for的底层是由Iterator来实现的，是其简化版</li>
<li>只要实现了Iterable接口的对象，就可以成为foreach的目标</li>
</ul>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a><em>Collections工具类</em></h2><ul>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code> ：像向集合中添加一系列元素</li>
<li><code>public static void shuffle(List&lt;?&gt; list)</code> ：打乱集合的排序顺序</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code> ：将集合中的元素按照默认的方式进行排序</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> ：按照Comparator实现接口的排序方式进行排序</li>
</ul>
<h3 id="针对自定义的类对象进行排序"><a href="#针对自定义的类对象进行排序" class="headerlink" title="针对自定义的类对象进行排序"></a>针对自定义的类对象进行排序</h3><ol>
<li>实现Comparable接口中的CompareTo方法<ul>
<li>其实像<code>Integer、String...</code>都是实现了这个接口的，所以我们自定义的类是需要自己定义比较规则的</li>
<li>排序规则：<ul>
<li>this - object 升序</li>
<li>object - this 降序</li>
</ul>
</li>
</ul>
</li>
<li>单独实现Comparator接口，然后将这个比较器作为参数传递到<code>Collection.sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>函数中<ul>
<li>对于数值可以直接返回相减的值（返回值是int）</li>
<li>对于字符串可以调用字符串本身实现了的<code>compareTo</code>方法来获取字符串的比较结果</li>
<li>排序规则<ul>
<li>o1 - o2 ：升序</li>
<li>o2 - o1 ：降序</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li><p>Map具有键值对的概念，是双列集合（Collection是单列集合）</p>
</li>
<li><p>一个元素包含两个值 (key, value)；键和值是一一对应的，但是数据类型不相互制约</p>
</li>
<li><p>key值不允许重复，而value的值可以重复</p>
</li>
<li><p>Map&lt;K, V&gt;中常用的方法</p>
<ul>
<li><code>public V put(K key, V value)</code> ：把指定的 键-值 对添加到Map中（已存在的key将会替换掉其value值）<ul>
<li>存储时，若key不重复，返回null</li>
<li>存储时，若key重复了，返回被替换的value值</li>
</ul>
</li>
<li><code>public V remove(Object key)</code> ：删除指定key所对应的键值对<ul>
<li>key存在返回删除的value值</li>
<li>key不存在返回null</li>
<li>这里有一个注意：当value是基本类型时，如果直接返回成int类型会出现将null赋值给int的异常。所以建议使用包装类integer来接收数据</li>
</ul>
</li>
<li><code>public V get(Object key)</code></li>
<li><code>boolean containsKey(Object key)</code> ：判断是否包含某个键</li>
</ul>
<ol>
<li>遍历方法一：<code>Set&lt;K&gt; keySet()</code> ：把Map集合中的所有key取出来，存储在一个Set集合中，使用Set的遍历结合<code>get(Object key)</code>来遍历Map集合</li>
<li>遍历方法二：<code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code><ul>
<li>在Map中，键值对的底层存储是放在了一个Entry的映射关系中，可以使用这个方法将这些Entry的映射关系全部放到一个Set的集合中，来实现遍历</li>
<li>然后使用Set的迭代器取出所有的Entry对象</li>
<li>再调用Entry的<code>getKey()</code> 和 <code>getValue()</code>方法来获得Entry对象中的键-值</li>
</ul>
</li>
</ol>
</li>
<li><p>Map存储自定义类型的键值，和Set集合一样必须重写自定义对象的<code>hashCode()</code> 和 <code>equals()</code> 两个方法</p>
</li>
</ul>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul>
<li>底层是哈希表实现</li>
<li>是一个无序集合，存取的顺序不一致</li>
<li>多线程实现的集合，不安全的集合，但是速度快</li>
</ul>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><ul>
<li>继承自HashMap</li>
<li>底层是哈希表+链表（保证迭代顺序）</li>
<li>有序集合，存取顺序一致</li>
</ul>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><ul>
<li>早期版本的双列集合，单线程实现的方法较为安全，但是速度较慢</li>
<li>HashMap可以存储null值，但是Hashtable不可以存储null值</li>
<li>Hashtable和Vector一样都已经被更先进的集合（HashMap、ArrayList）所代替</li>
<li>但是Hashtable的子类Properties依然在使用，它是唯一与IO流相结合的集合</li>
</ul>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><h1 id="👉并发"><a href="#👉并发" class="headerlink" title="👉并发"></a>👉并发</h1><h2 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h2><ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
</ul>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><ul>
<li>首先创建一个类，并要继承Thread类</li>
<li>重写run()方法之后，new一个对象之后调用start()方法来开启这个线程</li>
<li>main线程 –&gt; 主线程</li>
</ul>
<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><ul>
<li>首先实现Runnable接口，并重写run()方法</li>
<li>然后new一个实现了Runnable接口的对象的实例<code>thread1</code></li>
<li>创建一个Thread对象的实例，将<code>thread1</code>作为参数传入其构造方法</li>
<li>调用start方法来启动线程</li>
<li>继承Thread类和实现Runnable接口本质上是一样的</li>
</ul>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><ul>
<li>首先实现Callable接口，并重写Call()方法</li>
<li>相对于Runnable接口，可以自定义返回值、可以抛出异常</li>
<li>这里以线程返回为Boolean为例</li>
</ul>
<pre><code class="hljs java">Hello t1 = <span class="hljs-keyword">new</span> Hello();  
<span class="hljs-comment">//创建执行服务  </span>
ExecutorService srv = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);  
<span class="hljs-comment">//提交执行  </span>
Future&lt;Boolean&gt; r1 = srv.submit(t1);  
<span class="hljs-comment">//获取结果  </span>
<span class="hljs-keyword">try</span> &#123;  
    <span class="hljs-keyword">boolean</span> rs1 = r1.get();  
&#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;  
    e.printStackTrace();  
&#125;
<span class="hljs-comment">//关闭服务  </span>
srv.shutdown();</code></pre>

<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><ul>
<li>真实对象和代理对象都要实现同一个接口</li>
<li>代理角色要<strong>代理</strong>真实角色，将真实对象通过构造器传递给代理对象</li>
<li>优点：<ul>
<li>代理对象可以做很多真实对象无法做的事</li>
<li>真实对象专注于做自己的事</li>
</ul>
</li>
<li>其实实现Runnable接口的多线程编程就是这样的静态代理方式</li>
</ul>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ul>
<li>函数式接口：任何只包含唯一一个抽象方法的接口</li>
<li>对于函数式接口可以通过Lambda表达式来创建该接口的对象</li>
<li>本质上是简化代码量，使其更加简洁</li>
</ul>
<pre><code class="hljs java">Runnable thread1 = <span class="hljs-keyword">null</span>;  
thread1 = ()-&gt;&#123;  
    System.out.println(<span class="hljs-string">&quot;Thread1&quot;</span>);  
&#125;;</code></pre>

<ul>
<li>接口存在参数时，参数的类型是可以省略的。写成：<code>(a,b)-&gt;&#123;System.out.println(&quot;Thread&quot;);&#125;</code></li>
</ul>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ul>
<li>获取当前线程的信息<ul>
<li><code>Thread.currentThread().getName()</code></li>
<li><code>Thread.currentThread().getPriority()</code></li>
<li>……</li>
</ul>
</li>
</ul>
<h3 id="优先级priority"><a href="#优先级priority" class="headerlink" title="优先级priority"></a>优先级<code>priority</code></h3><ul>
<li>优先级数：1~10，数值越大优先级越高</li>
<li><code>thread.getPriority()</code> &amp; <code>thread.setPriority()</code></li>
<li>不显式设置优先级时，默认为5</li>
<li>优先级一定要在线程开始运行之前设置，否则没有意义</li>
</ul>
<h3 id="线程停止stop"><a href="#线程停止stop" class="headerlink" title="线程停止stop"></a>线程停止<code>stop</code></h3><ul>
<li>不推荐使用Thread类中提供的<code>stop()</code>、<code>destroy()</code>方法，这些方法已经弃用了</li>
<li>重写一个<code>stop()</code>方法，通过改变类中的一个标志位，来使线程跳出死循环从而实现线程自己停止结束</li>
</ul>
<h3 id="线程休眠sleep"><a href="#线程休眠sleep" class="headerlink" title="线程休眠sleep"></a>线程休眠<code>sleep</code></h3><ul>
<li>毫秒级的延时<code>Thread.sleep(int millis)</code></li>
<li>阻塞当前的线程</li>
<li>存在异常<code>InterruptedException</code></li>
<li><code>sleep()</code>并不会释放锁</li>
</ul>
<h3 id="线程礼让yield"><a href="#线程礼让yield" class="headerlink" title="线程礼让yield"></a>线程礼让<code>yield</code></h3><ul>
<li><code>Thread.yield()</code></li>
<li>让线程回到就绪队列，让CPU重新调度任务</li>
<li>所以调用这个函数不一定会使其他线程执行</li>
</ul>
<h3 id="线程合并join"><a href="#线程合并join" class="headerlink" title="线程合并join"></a>线程合并<code>join</code></h3><ul>
<li><code>thread.join()</code></li>
<li>让当前的线程等待指明的这个thread线程结束后再执行</li>
</ul>
<h3 id="守护线程-daemon"><a href="#守护线程-daemon" class="headerlink" title="守护线程(daemon)"></a>守护线程(<code>daemon</code>)</h3><ul>
<li>线程分为用户线程 和 守护线程</li>
<li>JVM虚拟机保证用户线程执行完毕，但不保证守护线程</li>
<li>守护线程有：记录操作日志、监控内存、垃圾回收……</li>
<li>将线程设置为守护线程<code>thread.setDaemon(true)</code>，默认是false表示用户线程</li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h4 id="两种用法：synchronized方法-amp-synchronized块"><a href="#两种用法：synchronized方法-amp-synchronized块" class="headerlink" title="两种用法：synchronized方法 &amp; synchronized块"></a>两种用法：<code>synchronized</code>方法 &amp; <code>synchronized</code>块</h4><ol>
<li>将方法声明为<code>private synchronized void method()</code> –&gt; 影响性能<ul>
<li>每个==对象==都有一个内置🔒，在调运这个方法时需要先获得这个内置的🔒</li>
<li>对于static的方法也可以加<code>synchronized</code>，但是这会锁住整个类</li>
</ul>
</li>
<li>同步块：<code>synchronized (object)&#123;...&#125;</code></li>
</ol>
<ul>
<li>同步方法是锁住的<code>this</code>对象，有时并不会按照我们预期的那样来运行</li>
</ul>
<h2 id="锁-Lock"><a href="#锁-Lock" class="headerlink" title="锁 (Lock)"></a>锁 (Lock)</h2><ul>
<li>显式定义同步锁来实现同步，底层的实现和前者是一样的</li>
<li>相对于<code>synchronized</code>，它是可重入锁</li>
<li>模板：</li>
</ul>
<pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;  
    threadLock.lock();  
 <span class="hljs-keyword">if</span>(ticket &gt; <span class="hljs-number">0</span>)&#123;  
        System.out.println(ticket--);  
  Thread.sleep(<span class="hljs-number">1000</span>);  
  &#125;<span class="hljs-keyword">else</span> &#123;  
        <span class="hljs-keyword">break</span>;  
  &#125;  
&#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;  
    e.printStackTrace();  
&#125;<span class="hljs-keyword">finally</span> &#123;  
    threadLock.unlock();  
&#125;</code></pre>

<h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><ul>
<li>使用<code>this.wait() &amp; this.notify/notifyAll()</code>两个方法来进行</li>
<li>这些方法是属于Object类的方法，并且必须在<code>synchronized</code>的临界区使用</li>
<li><code>this.wait()</code>被调用时，会释放此时持有的🔒</li>
<li>特别注意：<code>notify/notifyAll</code>两者的区别<ul>
<li><code>notify</code>只会唤醒一个在等待池中的进程，并开始竞争CPU和🔒</li>
<li><code>notifyAll</code>会唤醒所有在等待池中的进程，唤醒的进程同时开始竞争CPU和🔒</li>
</ul>
</li>
</ul>
<h3 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h3><h3 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h3><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li>使用线程池可以提高相应速度，避免频繁的创建销毁，便于线程的管理<br>前面出现过了：</li>
</ul>
<pre><code class="hljs java">ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);  
service.execute(thread);  
service.shutdown();</code></pre>

<h1 id="👉网络"><a href="#👉网络" class="headerlink" title="👉网络"></a>👉网络</h1><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a><code>InetAddress</code>类</h3><ul>
<li>这个类没有构造方法无法实例化，只能通过其静态方法获得对象</li>
</ul>
<pre><code class="hljs java">InetAddress srv = InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>);  
InetAddress sw = InetAddress.getByName(<span class="hljs-string">&quot;192.168.0.1&quot;</span>);  
InetAddress cli = InetAddress.getLocalHost();</code></pre>

<ul>
<li>然后可以使用特定方法输出主机名、主机地址</li>
<li>所以这个类一般不通过生成一个对象来使用，而是直接调用静态方法来获取信息</li>
</ul>
<h3 id="InetSocketAddress类"><a href="#InetSocketAddress类" class="headerlink" title="InetSocketAddress类"></a><code>InetSocketAddress</code>类</h3><ul>
<li>相对于<code>InetAddress</code>多了port端口参数</li>
<li>拥有构造函数，需要进行实例化</li>
</ul>
<h2 id="TCP套接字"><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h2><h3 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a><code>ServerSocket</code>类</h3><ul>
<li>针对服务器建立的套接字，需要写入监听的端口</li>
<li>调用其<code>accept()</code>方法，返回客户端连接的<code>Socket</code>套接字</li>
</ul>
<h3 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a><code>Socket</code>类</h3><ul>
<li>构造函数中写入要连接的服务器地址端口，获得一个连接的套接字</li>
<li>通过<code>getOutputStream()</code> 和 <code>getInputStream()</code>方法来获得输入输出流</li>
</ul>
<h3 id="字节流接收"><a href="#字节流接收" class="headerlink" title="字节流接收"></a>字节流接收</h3><ul>
<li>需要一个中间的管道<code>ByteArrayOutputStream</code>来进行转换</li>
</ul>
<pre><code class="hljs java"><span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];  
<span class="hljs-keyword">int</span> len;  
ByteArrayOutputStream baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();  
<span class="hljs-keyword">while</span> ((len=is.read(buffer))!=-<span class="hljs-number">1</span>)&#123;  
    baos.write(buffer,<span class="hljs-number">0</span>,len);  
&#125;
System.out.println(baos.toString());</code></pre>

<h2 id="UDP套接字"><a href="#UDP套接字" class="headerlink" title="UDP套接字"></a>UDP套接字</h2><h3 id="DatagramSocket类"><a href="#DatagramSocket类" class="headerlink" title="DatagramSocket类"></a><code>DatagramSocket</code>类</h3><ul>
<li>构造方法，传入port端口来指定要监听的端口</li>
<li>使用<code>send()</code>方法来发送用<code>DatagramPacket</code>构建的数据报文</li>
<li>使用<code>receive()</code>方法来接收用<code>DatagramPacket</code>构建的数据报空间</li>
</ul>
<h3 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a><code>DatagramPacket</code>类</h3><ul>
<li>用来建立数据报，包含字节流数据、要发送的地址端口</li>
<li>也可以用来创建接收数据报文的空间，需要注意使用的存储空间是Byte[]</li>
</ul>
<h2 id="URL资源"><a href="#URL资源" class="headerlink" title="URL资源"></a>URL资源</h2><ul>
<li>使用<code>HttpURLConnection</code>类进行资源的连接</li>
</ul>
<pre><code class="hljs java">URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;https://www.****.com/photo.jpg&quot;</span>);
HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();  
InputStream is = urlConnection.getInputStream();  
FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;photo.jpg&quot;</span>);  
  
<span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];  
<span class="hljs-keyword">int</span> len;  
<span class="hljs-keyword">while</span> ((len=is.read(buffer))!=-<span class="hljs-number">1</span>) &#123;  
    fos.write(buffer,<span class="hljs-number">0</span>,len);  
&#125;</code></pre>

<h1 id="👉注解"><a href="#👉注解" class="headerlink" title="👉注解"></a>👉注解</h1><ul>
<li>注解(Annotation) 和 注释有一定的相似性</li>
<li>注解不是必须的，但是对程序有一定的作用</li>
</ul>
<h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><ul>
<li><code>@Override</code> ：重写的方法</li>
<li><code>@Deprecated</code> ：被遗弃，不在推荐使用的方法</li>
<li><code>@SuppressWarnings(&quot;all&quot;)</code> ：抑制编译时的警告信息，除了<code>&quot;all&quot;</code>之外还可以使用其他的参数</li>
</ul>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><ul>
<li>元注解(meta-annotation)作用是注解其他的注解，为其他注解类型提供说明</li>
<li>四个标准的元注解<ol>
<li><code>@Target</code> ：描述注解使用的范围，在<code>ElementType</code>这个枚举类型中去找定义</li>
<li><code>@Retention</code> ：描述注解的生命周期。(SOURCE &lt; CLASS &lt; <strong>RUNTIME</strong>) 一般直接写RUNTIME</li>
<li><code>@Documented</code> ：表示是否将我们的注解生成在JAVAdoc中</li>
<li><code>@Inherited</code> ：表示子类可以继承父类中的注解</li>
</ol>
</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><pre><code class="hljs java"><span class="hljs-meta">@Target(value = &#123;ElementType.METHOD&#125;)</span>  
<span class="hljs-meta">@Retention(value = RetentionPolicy.RUNTIME)</span>  
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;  
    <span class="hljs-comment">//注解的参数：参数类型 + 参数名 ();  </span>
    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;  <span class="hljs-comment">//default表示调运注解不对其赋值时的默认值</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span></span>;  
    String[] school();  
&#125;

<span class="hljs-comment">//使用注解</span>
<span class="hljs-meta">@MyAnnotation(name = &quot;LZH&quot;, age = 19, school = &quot;电子科大&quot;)</span></code></pre>

<ul>
<li>当注解只有一个参数时，建议使用<code>valuse</code>。这样在使用注解的时候可以不用写<code>valuse =</code>，直接写要赋的值</li>
</ul>
<h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><ol>
<li>编译检查：<code>@SuppressWarnings</code>, <code>@Deprecated</code>和 <code>@Override</code>都用编译检查的功能</li>
<li>在反射中使用注解：这是注解最为重要的功能，在通过反射来调用对象方法时，可以反射出注解中的内容，从而影响程序的运行；这在各种框架中被广泛使用</li>
<li>根据注解生成帮助文档，<code>@Documented</code>标签的功能</li>
</ol>
<h1 id="👋反射"><a href="#👋反射" class="headerlink" title="👋反射"></a>👋反射</h1><ul>
<li>静态语言 VS 动态语言<ul>
<li>静态语言运行时结构不可变，动态语言运行时的结构是可以改变的</li>
<li>反射机制将本来是静态语言的Java变成了==准动态语言==</li>
</ul>
</li>
<li>反射允许程序在执行期间借助Reflection API取得任何类的内部信息，并能够直接操作对象的内部属性及方法</li>
</ul>
<h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><ul>
<li>一共有三种方式来获取Class对象：<ol>
<li>通过实例对象的<code>getClass()</code>方法（继承自Object类的方法）获取</li>
<li>通过类的属性值直接获取<code>Object.Class</code>，但是这种方法需要导入相关的包</li>
<li>使用Class类的静态方法，通过目标类真实路径的字符串来获取<code>Class.forName(&quot;fanshe.Student&quot;)</code></li>
</ol>
</li>
</ul>
<h3 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h3><ul>
<li>获取构造方法之前，需要先拿到类的Class对象，然后调用Class的实例方法来查找构造器</li>
<li>查找所有的构造器<code>getDeclaredConstructors()</code>或<code>getConstructors()</code>（前者是查找所有构造器，后者是查找所有**<em>公有**</em>的构造器）</li>
<li>查找指定的构造器（即给定传入参数的类型）：</li>
</ul>
<pre><code class="hljs java">Class[] p2 = &#123;<span class="hljs-keyword">int</span>.class, String.class&#125;;
Constructor constructor = cstd.getDeclaredConstructor(p2);
constructor.setAccessible(<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//更改构造器的访问权限，使得private的构造器也能调用</span>
Object obj = constructor.newInstance(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;Jobs&quot;</span>); <span class="hljs-comment">//返回的直接类型都是Object的</span>
Student std2 = (Student) constructor.newInstance(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;Jobs&quot;</span>); <span class="hljs-comment">//可以强制类型转化</span></code></pre>

<ul>
<li>带有<code>Declared</code>的 就是查找所有的，没带的就是只查找公有的</li>
</ul>
<h3 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h3><ul>
<li>获取所有的成员变量（分有<code>Declared</code>和没有两种）：</li>
</ul>
<pre><code class="hljs java">Field[] fieldArray = cstd.getDeclaredFields();
Field[] fieldArray = cstd.getFields();</code></pre>

<ul>
<li>通过变量名，获取具体的某个成员变量（分有<code>Declared</code>和没有两种）：</li>
</ul>
<pre><code class="hljs java">Field f = cstd.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);  
f.setAccessible(<span class="hljs-keyword">true</span>);  <span class="hljs-comment">//更改访问权限，解除私有限定</span>
f.set(std, <span class="hljs-number">100</span>); <span class="hljs-comment">//设置std这个实例对象中的f所指向的局部变量的值</span></code></pre>

<h3 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h3><ul>
<li>获取所有成员方法</li>
</ul>
<pre><code class="hljs java">Method[] methodArray = cstd.getDeclaredMethods();</code></pre>

<ul>
<li>获取指定的成员方法并调用：</li>
</ul>
<pre><code class="hljs java">Method m = cstd.getDeclaredMethod(<span class="hljs-string">&quot;testMethod&quot;</span>, <span class="hljs-keyword">int</span>.class, String.class);  
m.setAccessible(<span class="hljs-keyword">true</span>);  
Object obj = m.invoke(std, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;Jobs&quot;</span>); <span class="hljs-comment">//返回值的类型都是Object的，可以做强制类型转换</span></code></pre>

<h3 id="反射注解"><a href="#反射注解" class="headerlink" title="反射注解"></a>反射注解</h3><ul>
<li>获取到注解的字段中的内容，根据注解的内容改变程序执行的逻辑</li>
</ul>
<pre><code class="hljs java">Host host = <span class="hljs-keyword">new</span> Host();  
<span class="hljs-keyword">if</span> (host.getClass().isAnnotationPresent(MyAnnotation.class)) &#123;  
	MyAnnotation annotation = host.getClass().getAnnotation(MyAnnotation.class);  
	String value = annotation.value();  
	System.out.println(value);  
&#125;</code></pre>

<h3 id="反射main方法"><a href="#反射main方法" class="headerlink" title="反射main方法"></a>反射main方法</h3><pre><code class="hljs java">Method m = cstd.getMethod(<span class="hljs-string">&quot;main&quot;</span>, String[].class);  
m.invoke(<span class="hljs-keyword">null</span>, (Object) <span class="hljs-keyword">null</span>);</code></pre>

<h3 id="通过反射运行配置文件"><a href="#通过反射运行配置文件" class="headerlink" title="通过反射运行配置文件"></a>通过反射运行配置文件</h3><h3 id="通过反射越过泛型检查"><a href="#通过反射越过泛型检查" class="headerlink" title="通过反射越过泛型检查"></a>通过反射越过泛型检查</h3>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/10/28/helloWorld/">
                        <span class="hidden-mobile">helloWorld</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "JavaSE&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>















</body>
</html>
